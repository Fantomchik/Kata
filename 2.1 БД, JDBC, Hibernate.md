- [1. Что такое Maven? Для чего он нужен? Как добавлять в проект библиотеки без него?](#1-что-такое-maven-для-чего-он-нужен-как-добавлять-в-проект-библиотеки-без-него)
- [2. Как добавить dependency в Maven? Для чего они нужны? Откуда они скачиваются?](#2-как-добавить-dependency-в-maven-для-чего-они-нужны-откуда-они-скачиваются)
- [3. Основные фазы проекта под управлением Maven?](#3-основные-фазы-проекта-под-управлением-maven)
- [4. Что такое JDBC? Какие классы/интерфейсы относятся к JDBC?](#4-что-такое-jdbc-какие-классыинтерфейсы-относятся-к-jdbc)
- [5. Для чего нужен DriverManager?](#5-для-чего-нужен-drivermanager)
- [6. Что такое Statement, PreparedStatement, CallableStatement?](#6-что-такое-statement-preparedstatement-callablestatement)
- [7. Что такое sql-injection?](#7-что-такое-sql-injection)
- [8. Что такое ResultSet? Как с ним работать?](#8-что-такое-resultset-как-с-ним-работать)
- [9. Рассказать про паттерн DAO.](#9-рассказать-про-паттерн-dao)
- [10. Что такое JPA?](#10-что-такое-jpa)
- [11. Что такое ORM?](#11-что-такое-orm)
- [12. Что такое Hibernate?](#12-что-такое-hibernate)
- [13. В чем разница между JPA и Hibernate? Как связаны все эти понятия?](#13-в-чем-разница-между-jpa-и-hibernate-как-связаны-все-эти-понятия)
- [14. Какие классы/интерфейсы относятся к JPA/Hibernate?](#14-какие-классыинтерфейсы-относятся-к-jpahibernate)
- [15. Основные аннотации Hibernate, рассказать.](#15-основные-аннотации-hibernate-рассказать)
- [16. Чем HQL отличается от SQL?](#16-чем-hql-отличается-от-sql)
- [17. Что такое Query? Как передать в объект Query параметры?](#17-что-такое-query-как-передать-в-объект-query-параметры)
- [18. Какие можно устанавливать параметры в hbm2ddl, рассказать про каждый из них.](#18-какие-можно-устанавливать-параметры-в-hbm2ddl-рассказать-про-каждый-из-них)
- [19. Требования JPA к Entity-классам? Не менее пяти.](#19-требования-jpa-к-entity-классам-не-менее-пяти)
- [20. Жизненный цикл Entity в Hibernate? Рассказать.](#20-жизненный-цикл-entity-в-hibernate-рассказать)
  


## 1. Что такое Maven? Для чего он нужен? Как добавлять в проект библиотеки без него?

при работе с любыми классами, необходимо сделать классы доступными для компилятора и рабочего окружения. Сконфигурируйте переменную окружения CLASPATH или скопируйте соответствующий JAR-файл со всеми его классами в директорию $JAVA_HOME/jre/lib/ext, расположенную в основной инсталляционной директории Java 2 Platform (J2SE). Главное преимущество Maven — это управление зависимостями. Редко какие проекты пишутся без использования сторонних библиотек. Эти сторонние библиотеки зачастую тоже в свою очередь используют библиотеки разных версий. Maven позволяет управлять такими ==сложными зависимостями, что позволяет разрешать конфликты версий и в случае необходимости легко переходить на новые версии библиотек. == Добавить самому - project structure - Libraries Maven - система управления жизненным циклом проекта. Это инструмент стандартизации сборки и дальнейшего развертывания проекта, а так же управлением зависимостями. Предназначен для создания документации, автоматической загрузки зависимостей и автоматической сборки проектов, написанных на Java, Groovy и др. языках. Это фреймворк для создания проектов с большим количеством шаблонов структур проекта и фреймворков. В зависимости от архетипа будут созданы проекты с разной иерархией файлов и папок. Создавать сложные проекты вручную это громоздко, долго и неудобно. Сейчас в целях стандартизации сборки и дальнейшего развертывания используются специальные инструменты типа Maven. Одна из вещей, которую Maven стандартизировал в первую очередь, — это описание проекта. До Maven у каждой IDE был свой project-файл, который хранил информацию о проекте и его сборке (и зачастую в бинарном виде). Maven предложил универсальный открытый стандарт на основе XML, в котором с помощью различных тегов описывается, что это за проект, как его нужно собирать и какие у него зависимости. Вся необходимая информация о проекте заключена в одном файле, обычно с именем pom.xml. До Мавена сборка проекта происходила посредством скрипта в баше или шелле, который представлял собой последовательность команд. Подтягивание зависимостей было очень грустное- скачивался JAR-ник с каких-т ресурсов, через Project Structure -> Dependencies -> добавление этого джарника импортировалась библиотека.

## 2. Как добавить dependency в Maven? Для чего они нужны? Откуда они скачиваются?

Артефакт (от лат. artefactum – искусственно сделанное) – любая библиотека, результат сборки проекта. Это элемент, который Maven может либо использовать, либо создать. Могут быть разных типов jar, war, zip, swf. В стандарте Maven артефактом можно назвать как программу, так и проект, модуль, библиотеку и тому подобное. У любого артефакта есть координаты - уникальный набор, состоящий из версии, упаковки, идентификаторы группы и идентификатора артефакта: GroupId - ключ, ускоряющий организацию и поиск проекта. Это параметр, указывающий группу или отдельное лицо, создавшее проект, который часто является обратным доменным именем компании. В качестве groupid обычно выступает имя верхнего пакета проекта. artifactId - это базовое имя проекта(уникальный строковый идентификатор), по умолчанию используется в качестве конечного имени артефакта. Это идентификатор, позволяющий выделить данный проект среди проектов с одинаковым groupId. Наилучшей практикой считается использование фактического названия проекта в качестве префикса. Это упрощает поиск артефактов. version - версия проекта, все проекты, которые были выпущены, имеют версию. Проекты в стадии активной разработки могут иметь специдентификатор SNAPSHOT. packaging - тип упаковки проекта. По умолчанию используется jar. Проект с упаковкой jar собирается в JAR - архив. Проект с упаковкой war собирается в WAR - архив(вебприложения). Этот элемент используется для указания типа артефакта, сгенерированного проектом. Упаковкой может быть что угодно, описывающее любой двоичный формат программного обеспечения, включая ZIP, EAR, WAR, SWC, NAR, SWF, SAR. Репозиторий - это хранилище артефактов. Есть три вида репозиториев: локальный - директория на диске, содержащая дерево каталогов артефактов(место на компуктере,где хранятся библиотеки). Во время сборки проекта артефакты должны находиться в локальном репозитории. Если каких-то артефактов нет, они подгружаются с других репозиториев. центральный - находится по адресу http://repo1.maven.org/maven2 . Но для просмотра и загрузки его содержимого через браузер следует использовать http://search.maven.org/ . удаленный - сервер, с которого загружаются артефакты. По сути центральный репозиторий частный случай удаленного. Следующая фишка Maven - управление зависимостями. Для того, чтобы добавить какуюлибо библиотеку в наш проект, необходимо просто прописать dependency в pom.xml - файле. допустим, для того ,чтобы добавить в наш проект последние версии Spring и Hibernate, необходимо сделать следующее:
```
<dependencies>

    <dependency>
        <qroupId>org.springframework</qroupId>
        <artifactId>spring-core</artifactId>
        <version>5.3.18</version>
    </dependency>

    <dependency>
        <groupId>ord.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>6.0.0.Final</version>
    </dependency>

</dependencies>
```

Все, более никаких действий не требуется. Теперь мы можем пользоваться классами указанных библиотек, и что самое главное, если залить проект на GitHub или переслать кому-то в виде архива, человек по ту сторону гарантированно сможет его собрать, поскольку вся информация по зависимостям, библиотекам и сценариям сборки уже зашита в проект. Зависимости которые мы подключаем - по факту программы Java, которые писали другие люди и указывали groupId и artifactId, которые мы указываем при создании проекта Maven. Во время сборки Maven будет искать указанную библиотеку(артефакт) в локальном репозитории . Если в локальном репозитории ее не обнаружится, он будет проводить поиск в центральном глобальном Maven - репозитории, а затем загрузит его в твой локальный репозиторий для ускорения сборки в дальнейшем.

## 3. Основные фазы проекта под управлением Maven?

Жизненный цикл сборки в Maven – это чётко определённая последовательность фаз во время
выполнения которых должны быть достигнуты определённые цели. Периоды жизненного цикла
проекта и что они делают:

I. Prepare-resources(Копирование ресурсов):
- "clean" в Lifecycl'e удалит папку target со скомпилированным кодом.
- "validate" провалидирует наш проект на корректность, полноту информации. Показывает, можно ли его скомпилировать. Проверяет корректность метаинформации о проекте
  
II. Compile(компиляция):
- "compile" скомпилирует код.
- "test"- прогоняет тесты классов из предыдущего шага.
  
III. Package(Создание пакета):
- "package" - упакует скомпилированный код в JAR-ник или какой-то другой тип.
- "verify" - проверяет корректность артефакта и удовлетворение требованиям качества.
  
IV. Install(Установка):
- "install" - перенесет проект в локальный репозиторий, из которого уже можно будет работать с какими-то другими проектами.
- "site" - предназначен для создания документации.
- "deploy" - размещение проекта в удаленном репозитории.

clean и site. clean используется для того, чтобы полностью очистить папку target, а site умеет создавать документацию проекта.

## 4. Что такое JDBC? Какие классы/интерфейсы относятся к JDBC?

JDBC API - стандартный прикладной интерфейс Java, обесепчивающий взаимодействие приложения с СУБД. Это платформенно- независимый стандарт взаимодействия с реляционными БД, реализованный в Java в пакете java.sql(JDBC API). Является самым низкоуровневым API взаимодействия с СУБД, обладающим низким уровнем автоматизации и абстракции.
Здесь мы сами делаем запросы и сами переводим объекты Java в строки таблицы. JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

```
public void saveUser(String name, String lastName, byte age) {
    try (PreparedStatement pstm = connection.prepareStatement(INSERT_VALUES)) {
        pstm.setString(1, name);
        pstm.setString(2, lastName);
        pstm.setByte(3, age);
        pstm.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```
Помимо того, что он имеет низкий уровень абстракции и все делается "вручную", при наличии ошибки, будет выбрасывать SQLException, т.е. сложно понять, в чем проблема.

JDBC решает следующие задачи:

- JDBC – Java DataBase Connectivity – соединение с базами данных на Java. Это стандарт взаимодействия с БД. Его интерфейс поставляется в стандартной JDK в виде пакета java.sql. Какой бы библиотекой для работы с базой данных вы ни пользовались, в ее основе почти всегда лежит низкоуровневый JDBC. Создание соединения с БД.
- Создание SQL выражений.
- Выполнение SQL – запросов.
- Просмотр и модификация полученных записей
  
В JDBC есть 3 основных интерфейса:
- Connection – отвечает за соединение с базой данных. Интерфейс Connection представляет сессию соединения с базой данных, обеспечиваемую драйвером. Он также обеспечивает методы для создания выражений, управления соединениями и их свойствами.
- Statement – отвечает за запрос к базе данных
- ResultSet – отвечает за результат запроса к базе данных
  
Существует два интерфейса подключения к БД:
- Через DriverManager
- Через DataSource
  
- java.sql.DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.
- javax.sql.DataSource - решает те же задачи, что и DriverManager, но более удобным и универсальным образом. Существуют также javax.sql.ConnectionPoolDataSource и javax.sq1.XADataSource задача которых - обеспечение поддержки пула соединений.
- java.sql.Connection - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также предусмотрены интерфейсы javax.sql.PooledConnection и javax.sql.XAConnection.
- java.sql.Statement , java.sql.PreparedStatement и java.sql.CallableStatement - эти интерфейсы позволяют отправить запрос к источнику данных.
- java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения отдельных полей в текущей записи.
- java.sql.ResultSetMetaData - позволяет получить информацию о структуре набора данных.
- java.sql.DatabaseMetaData - позволяет получить информацию о структуре источника данных.
  
## 5. Для чего нужен DriverManager?

Java-приложение и база данных общаются друг с другом посредством библиотеки, которая называется JDBC Driver Это набор классов, которые реализуют JDBC API для конкретной СУБД. Драйвер отображает JDBC-команды на используемую вами базу данных. Каждый запрос на соединение требует соответствующего драйвера. Правильный JDBC драйвер выбирается с помощью класса под названием DriverManager. В приложении может быть зарегистрировано несколько разных драйверов. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается. При соединении к базе, нужный выбирается исходя из URL соединения. Например, для jdbc:mysql://localhost:3306/db_name будет использован MySQL JDBC. Класс DriverManager является уровнем управления JDBC, отслеживает все доступные драйверы и управляет установлением соединений между БД и соответствующим драйвером. Он содержит список зарегистрированных в системе JDBC-драйверов и устанавливает соединение с драйвером. Данный класс используется в основном для получения ссылки на объект Connection посредством метода getConnection. При вызове метода getConnection DriverManager попытается найти подходящий драйвер среди тех, которые загружаются при инициализации, и тех, которые загружаются явно с использованием того же загрузчика классов, что и текущее приложение.
Мы абстрагируемся от строения конкретной базы данных, а используем унифицированный интерфейс, который един для всех. getConnection(String url) Пытается установить соединение с URL-адресом заданной базы данных. getConnection(String url, Properties info) Пытается установить соединение с URL-адресом заданной базы данных. Параметры: url – адрес в формате jdbc:subprotocol:subname, info – список произвольных пар тег/значение типа String, передаваемых в качестве аргументов соединения. Обычно должна быть включена хотя бы одна пара «имя пользователя»/«пароль».
getConnection(String url, String user, String password) Пытается установить соединение с URL-адресом заданной базы данных. Параметры: url – адрес в формате jdbc:subprotocol:subname, user – пользователь базы данных, от имени которого устанавливается соединение, password – пароль пользователя. 

## 6. Что такое Statement, PreparedStatement, CallableStatement? 

Statement - (объект для оператора JDBC) используется для отправки SQL-оператора на сервер баз данных. Объект для оператора связан с объектом Connection и является объектом, обрабатывающим взаимодействие между приложением и сервером баз(объект для оператора JDBC).

1) Statement — используется для выполнения обычных запросов SQL. Вы не можете передавать параметры SQL-запросу во время выполнения с помощью этого интерфейса. Этот интерфейс предпочтительнее двух других интерфейсов, если вы выполняете конкретный SQL-запрос только один раз.
2) PreparedStatement — используется для выполнения динамических или параметризованных запросов SQL. Вы можете передать параметры SQL-запросу во время выполнения, используя этот интерфейс. Рекомендуется использовать PreparedStatement, если вы выполняете конкретный SQL-запрос несколько раз.
3) CallableStatement — используется для выполнения хранимых процедур. Процедура хранения — это группа операторов SQL, которая инкапсулирует все запросы и компилируется.
Хранимая процедура похожа на функцию или метод в классе, за исключением того, что она находится в базе данных.

Некоторые из преимуществ PreparedStatement по сравнению с Statement:
1. PreparedStatement помогает нам предотвратить атаки с использованием SQL-инъекций, поскольку он автоматически экранирует специальные символы.
2. PreparedStatement позволяет нам выполнять динамические запросы с вводом параметров.
3. PreparedStatement предоставляет различные типы методов установки для установки входных параметров запроса.
4. PreparedStatement быстрее, чем Statement. Это становится более заметным, когда мы повторно используем PreparedStatement или используем его методы пакетной обработки для выполнения нескольких запросов.
5. PreparedStatement помогает нам писать объектно-ориентированный код с помощью методов установки, тогда как с Statement мы должны использовать конкатенацию строк для создания запроса. Если необходимо установить несколько параметров, написание запроса с использованием конкатенации строк выглядит очень некрасиво и подвержено ошибкам. 
   
   - .executeUpdate() - метод, вызываемый на объекте statement'a, позволяющий обновить таблицу, к которой мы обращаемся. Выполняет такие команды, как INSERT, UPDATE, DELETE, CREATE TABLE, DROP TABLE. 
   - .executeQuery(SQL-запрос) - метод statement'a, выполняющий запрос к нашей базе данных и возвращает объект типа ResultSet, который инкапсулирует результат SQL - запроса. 

После этого нам надо вручную поместить данные, полученные в ResultSet'e, в наш Java объект путем итерации ResultSet'a через цикл while, последовательно заполняя поля объекта с помощью сеттеров значениями, полученными из колонок.

## 7. Что такое sql-injection?

SQL инъекция — это один из самых доступных способов взлома сайта. Большинство веб-форм не имеют механизмов, которые бы исключали ввод дополнительной информации в поле. ==Это дает злоумышленникам возможность передать в базу данных собственные запросы через поля ввода формы. Они могут использовать эту уязвимость в разных преступных целях, начиная с кражи конфиденциальных данных и заканчивая манипулированием сведениями в базе. Внедрение SQL, в зависимости от типа используемой СУБД и условий внедрения, может дать возможность атакующему выполнить произвольный запрос к базе данных (например, прочитать содержимое любыхтаблиц, удалить, изменить или добавитьданные), получить возможность чтения и/или записи локальных файлов и выполнения произвольных команд на атакуемом сервере. ==Атака типа внедрения SQL может быть возможна из-за некорректной обработки входных данных, используемых в SQL-запросах. Суть таких инъекций – внедрение в данные (передаваемые через GET, POST запросы или значения Cookie) произвольного SQL кода, то по сути есть возможность творить с БД (чаще всего это MySQL) что угодно. Проверять нужно всё – числа, строки, даты, данные в специальных форматах.

## 8. Что такое ResultSet? Как с ним работать?

ResultSet ,инкапсулирует результат SQL - запроса. Представляет результирущий набор данных и обеспечивает приложению построчный доступ к результатам запросов. – чем-то похож на итератор: он позволяет устанавливать/менять текущую строку результата, а затем из этой текущей строки можно получить данные, т.е. обеспечивает приложению построчный доступ к результатам запросов. При обработке запроса ResultSet поддерживает указатель на текущую обрабатываемую строку. Ниже приведены методы для работы со строкой. 

1. next() - Переключиться на следёющую строку
2. previous() - Переключиться на предыдушую строку
3. isFirst() - Текущая строка первая?
4. isBeforeFirst() - Мы перед первой сткрокой?
5. isLast() - Текущая сткрока последняя?
6. isAfterLast() - Мы после последней строки?
7. absolute(int n) - Делает N-ю строку текущей
8. relative(int n) - Двигает текущую сткроку на N позиций вперёд. M может быть <0 
9. getRow() - Возвращает номер сроки
    

Доступ к данным ResultSet обеспечивает посредством набора get-методов, которые организуют доступ к колонкам текущей строки. Метод ResultSet.next используется для перемещения к следующей строке ResultSet, делая ее текущей. Затем из текущей строки объекта ResultSet можно получить данные из его колонок: getType(номерКолонки/имя колонки) - вытаскиваем данные соответствующего типа на объекте ResultSet. Предпочтительнее работа с именами колонок.

## 9. Рассказать про паттерн DAO.

Паттерн DAO(Data Access Object) заключается в том, что логика взаимодействия с БД выносится из самой model в отдельный класс. Паттерн проектирования, когда отдельный класс занимается взаимодействием с БД для конкретной сущности, называется DAO.

- используется для абстрагирования и инкапсулирования доступа к источнику данных,
- управляет соединением с источником данных для получения и записи данных,
- реализует необходимый для работы с источником данных механизм доступа.
- выполняет функцию адаптера между компонентом и источником данных.

## 10. Что такое JPA?

Воплощение концепции ORM.

JPA (Java Persistence API) это спецификация описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде. == Сам JPA не умеет ни сохранять, ни управлять объектами, JPA только ==определяет правила игры: как должен действовать каждый провайдер (Hibernate, EclipseLink, OJB, Torque и т.д.), реализующий стандарт JPA. Для этого JPA определяет интерфейсы, которые должны быть реализованы провайдерами. Также JPA определяет правила, как должны описываться метаданные отображения и как должны работать провайдеры. Каждый провайдер обязан реализовывать всё из JPA, определяя стандартное получение, сохранение и управление объектами. Помимо этого, провайдеры могут добавлять свои личные классы и интерфейсы, расширяя функционал JPA.

## 11. Что такое ORM?

ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». Необходимо обеспечить работу с данными в терминах классов, а не таблиц данных, и, напротив, преобразовать термины и данные классов в данные, пригодные для хранения в СУБД. Необходимо также обеспечить интерфейс для CRUD-операций над данными. В общем, необходимо избавиться от необходимости писать SQL-код для взаимодействия в СУБД.

Преимущества ORM в сравнение с JDBC:

- Позволяет нашим бизнес методам обращаться не к БД, а к Java-классам
- Ускоряет разработку приложения
- Основан на JDBC
- Отделяет SQL-запросы от ОО модели
- Позволяет не думать о реализации БД
- Сущности основаны на бизнес-задачах, а не на стуктуре БД
- Управление транзакциями

ORM состоит из:
- API, который реализует базовые операции (СОЗДАНИЕ, ЧТЕНИЕ, ИЗМЕНЕНИЕ, УДАЛЕНИЕ) объектов-моделей.
- Средства настройки метаданных связывания
- Техники взаимодействия с транзакциями, которая позволяет реализовать такие функции, как dirty checking, lazy association fetching и т.д.
  
А самыми распространёнными ORM фреймворком являются:
- Hibernate
- Java Object-Oriented Querying (jOOQ)
- MyBatis
- EclipseLink
- TopLink

Eсть 5 проблем, которые связаны с разницей между объектно-ориентированной моделью и реляционной моделью:
1. Наследование
    В реляционной модели нет никакого понятия, похожего на наследование, которое является одним из ключевых принципов ООП.
2. Идентификация
    Для БД есть только одна сущность, по которому объект может быть идентифицирован – это Первичный Ключ (Primary Key). В то время как в Java есть такие вещи, как (entity1 == entity2) и (object1.equals(object2)) .
3. Ассоциации
    В Java используются ссылки на объекты для ассоциации, а в реляционной модели – Внешний Ключ (Foreign Key).
4. Доступ
    В Java и в реляционной БД абсолютно разные способы получения доступа к объекту.
5. Инкапсуляция
    Крайне часто, при разработке приложений, придется столкнуться с тем, что объектно-ориентированная модель имеет больше классов, чем таблиц в БД.


## 12. Что такое Hibernate?

Hibernate - это провайдер, реализующий спецификацию JPA. Hibernate полностью реализует JPA плюс добавляет функционал в виде своих классов и интерфейсов, расширяя свои возможности по работе с сущностями и БД. Hibernate - это набор классов, которые реализуют JPA интерфейсы.

Фреймворк Java, предназначенная для решения задач объектно-реляционного отображения (ORM), самая популярная реализация спецификации JPA. Позволяет сократить объёмы низкоуровневого программирования при работе с реляционными базами данных; может использоваться как в процессе проектирования системы классов и таблиц «с нуля», так и для работы с уже существующей базой.

Задачи, решаемые Hibernate:
- решает задачу связи классов Java с таблицами базы данных
- обеспечивает связь типов данных Java с типами данных SQL
- предоставляет средства для автоматической генерации и обновления набора таблиц, построения запросов и обработки полученных данных и может значительно уменьшить время разработки, которое обычно тратится на ручное написание SQL- и JDBC-кода.
- автоматизирует генерацию SQL-запросов и освобождает разработчика от ручной обработки результирующего набора данных и преобразования объектов, максимально облегчая перенос (портирование) приложения на любые базы данных SQL.
  
```
@Override
public List<User> getAllUsers() {
    List<User> users = null;
    try (Session session = sessionFactory.openSession()) {
        session.beginTransaction();
        CriteriaBuilder builder = session.getCriteriaBuilder();
        CriteriaQuery<User> criteria = builder.createQuery(User.class);
        Root<User> root = criteria.from(User.class);
        criteria.select(root);
        users = session.createQuery(criteria).getResultList();
        session.getTransaction().commit();
    } catch (Exception e) {
        sessionFactory.getCurrentSession().getTransaction().rollback();
    }
    return users;
}
```

В отличие от SQL запросов через тот же JDBC , необходимо ВСЕГДА работать через ,транзакции, т.е. открываем транзакцию - выполняем операцию - закрываем транзакцию. Делается это для того, чтобы изменения отслеживались Hibernate, находясь в Persistence Context'e.

## 13. В чем разница между JPA и Hibernate? Как связаны все эти понятия?

Hibernate(2001 г. выхода) по сути является прародителем JPA (первая версия выпущена 11 мая 2006 г.)
Реализации спецификации JPA называют также `JPA Provider`.

Hibernate одна из самых популярных открытых реализаций последней версии спецификации (JPA 2.1). Даже скорее самая популярная, почти стандарт де-факто. То есть JPA только описывает правила и API, а Hibernate реализует эти описания, впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA). JPA это спецификация, а Hibernate - это ORM фреймворк/библиотека, которая совместима с JPA. Как и в классическом ООП, класс, который реализует интерфейс, может иметь дополнительные методы/свойства, так и Hiberante имеет больше фичей чем JPA.

`Hibernate - это набор классов, которые реализуют JPA интерфейсы.`


## 14. Какие классы/интерфейсы относятся к JPA/Hibernate?

Что от чего наследуется:

Query -> TypedQuery -> Query -> SQLQuery
EntityTransaction -> Transaction
EntityManager -> HibernateEntityManager -> Session
EntityManagerFactory -> HibernateEntityManagerFactory -> SessionFactory

EntityManagerFactory — это встроенный интерфейс JPA. EntityManagerFactory может быть использован для создания экземпляров EntityManager. Если вы хотите подключиться к другой базе данных, необходимо создать другой экземпляр EntityManagerFactory. EntityManager также является встроенным интерфейсом JPA. Он может быть создан с помощью экземпляра EntityManagerFactory. EntityManager описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. По сути - главный API для работы с JPA.

EntityManager представляет собой соединение базы данных. Вы можете использовать его для выполнения операций с базой данных, таких как вставка/обновление/удаление или запрос таблицы.

`JPA`-----------------------`JDBC по аналогии`------`Hibernate` 

`EntityManagerFactory`------`DataSource`------------`SessionFactory`

`EntityManager`-------------`Connection`------------`Session`

`JPQL`----------------------------------------------`HQL`

EntityTransaction также является встроенным интерфейсом JPA. Он может быть создан с помощью EntityManager.
Сделка EntityTransaction инкапсулирует транзакцию базы данных.

2.1.1. Transaction
Этот объект представляет собой рабочую единицу работы с БД. В Hibernate транзакции обрабатываются менеджером транзакций. Транзакция — упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое. Согласованное состояние — это состояние, которое подходит под бизнес-логику системы. То есть у нас не остается отрицательный баланс после перевода денег, номер счета не «зависает в воздухе», не привязанный к человеку, и тому подобное.

2.1.2. SessionFactory
Самый важный и самый тяжёлый объект (обычно создаётся в единственном экземпляре, при запуске приложения). Необходима как минимум одна SessionFactory для каждой БД, каждый из которых конфигурируется отдельным конфигурационным файлом.

2.1.3. Session
Сессия используется для получения физического соединения с БД. Обычно, сессия создаётся при необходимости, а после этого закрывается. Это связано с тем, что эти объекты крайне легковесны. Чтобы понять, что это такое, можно сказать, что создание, чтение, изменение и удаление объектов происходит через объект Session . Точно так же ,как и Connection представляет сессию соединения с БД посредством драйвера, так и Session (сессия) используется для получения физического соединения с базой данных (далее – БД). Благодаря тому, что сессия является легковесны объектом, его создают (т.е. открывают сессию) каждый раз, когда возникает необходимость, а потом, когда необходимо, уничтожают (т.е. закрывают сессию). Мы создаём, читаем, редактируем и удаляем объекты с помощью сессий. Мы стараемся создавать сессии при необходимости, а затем уничтожать их из-за того, что ни не являются потоко-безопасными и не должны быть открыты в течение длительного времени.

2.1.4. Query
Этот объект использует HQL или SQL для чтения/записи данных из/в БД. Экземпляр запроса используется для связывания параметров запроса, ограничения количества результатов, которые будут возвращены и для выполнения запроса.

2.1.5. Configuration
Этот объект используется для создания объекта SessionFactory и конфигурирует сам Hibernate с помощью конфигурационного XML-файла, который объясняет, как обрабатывать объект Session .

2.1.6. Criteria
Используется для создания и выполнения объектно-ориентированных запросов для получения объектов.

## 15. Основные аннотации Hibernate, рассказать.

@Entity
Эта аннотация указывает Hibernate, что данный класс является сущностью (entity bean). Такой класс должен иметь конструктор по-умолчанию (пустой конструктор).
Сущность является простым классом POJO.
- Наличие публично доступного конструктора без аргументов
- Класс, его методы и сохраняемые поля не должны быть final
- Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс.
- Сохраняемые поля должны быть доступны только с использованием методов класса

@Table
С помощью этой аннотации мы говорим Hibernate, с какой именно таблицей необходимо связать (map) данный класс. Аннотация @Table имеет различные аттрибуты, с помощью которых мы можем указать имя таблицы, каталог, БД и уникальность столбцов в таблец БД.

@Id
С помощью аннотации @Id мы указываем первичный ключ (Primary Key) данного класса.

@GeneratedValue
Эта аннотация используется вместе с аннотацией @Id и определяет такие паметры, как strategy и generator Значение генерируется в базе и добавляется в поле нашего объекта. GenerationType.IDENTITY полагается на автоматическое увеличение значения столбца по правилам, прописанным в БД-х. Для MySQL является наиболее правильной и распространенной стратегией, которую и стоит указывать, поскольку в зависимости от версии Hibernate стратегия AUTO меняется.

Существует 4 варианта генерации первичных ключей

1. GenerationType.AUTO является типом генерации по умолчанию и позволяет поставщику персистентности выбрать стратегию генерации.
Если вы используете Hibernate в качестве поставщика персистентности, он выбирает стратегию генерации на основе конкретного диалекта базы данных. Для большинства популярных баз данных он выбирает GenerationType.SEQUENCE .

2. GenerationType.IDENTITY-самый простой в использовании, но не самый лучший с точки зрения производительности . Он опирается на автоматически увеличивающийся столбец базы данных и позволяет базе данных генерировать новое значение при каждой операции вставки. С точки зрения базы данных это очень эффективно, поскольку столбцы автоматического приращения сильно оптимизированы и не требуют никаких дополнительных операторов.
Этот подход имеет существенный недостаток, если вы используете Hibernate. Hibernate требует значения первичного ключа для каждой управляемой сущности и поэтому должен немедленно выполнить инструкцию insert. Этот предотвращает использование различных методов оптимизации, таких как пакетирование JDBC.

3. GenerationType.SEQUENCE использует последовательность базы данных для генерации уникальных значений. Для получения следующего значения из последовательности базы данных требуются дополнительные операторы select. Но это не имеет никакого значения воздействие для большинства применений .
Если вы не предоставите никакой дополнительной информации, Hibernate запросите следующее значение из последовательности по умолчанию. Вы можете изменить это , обратившись к имени @SequenceGenerator в генераторе атрибут аннотации @GeneratedValue . Аннотация @SequenceGenerator позволяет определить имя генератора, имя и схему последовательности базы данных, а также размер распределения последовательности.

4. GenerationType.TABLE используется очень редко . Он имитирует последовательность путем хранения и обновления ее текущего значения в таблице базы данных, которая требует использования пессимистических блокировок, которые ставят все операции в последовательном порядке. Это замедляет ваше приложение, и поэтому вы должны предпочесть GenerationType.SEQUENCE, если ваша база данных поддерживает последовательности, что делают большинство популярных баз данных.
   

@Column
Аннотация @Column определяет к какому столбцу в таблице БД относится конкретное поле класса (аттрибут класса).

Имеет различные атрибуты:
- String name - задает имя колонки таблицы для поля класса
- boolean unique - все значения должны быть уникальны
- boolean nullable - поле может принимать значение null
- int length - максимальная длина(для строк)

@ManyToMany, @ManyToOne, OneToMany
Диаграммы отношений сущностей, которая показывает связь "многие ко многим" между двумя сущностями

## 16. Чем HQL отличается от SQL?

HQL (Hibernate Query Language) - это объекто-ориентированный язык запросов, который очень похож на SQL. Главное различие языков HQL и SQL связано с тем, что SQL формирует запросы из наименований таблиц в базе данных и их столбцов, а HQL работает с сущностями (классами) и их полями (аттрибутами класса). HQL поддерживает такие понятия, как полиморфизм, наследование, ассоциация.

## 17. Что такое Query? Как передать в объект Query параметры?

Query – это вспомогательный интерфейс , использующийся для написания запросов к сущностям. и у него есть несколько реализаций на разные случаи. Объектно-ориентированное представление запроса в Hibernate. Запрос экземпляра получается вызовом Session.createQuery ().
Query - часть спецификации Java Persistence API (JPA).
Hibernate может использовать оператор WHERE с именованными параметрами (Named Parameters), определяя значение в режиме run-time. Для подстановки соответствующего значения в запрос используется метод setParameter объекта Query, которому в качестве параметров необходимо передать значения :

```
String hql = "FROM User where name = :paramName";
Query query = session.createQuery(hql);
query.setParameter("paramName", "Alex");
List<User> users = query.list();
```

## 18. Какие можно устанавливать параметры в hbm2ddl, рассказать про каждый из них.

`hibernate.hbm2ddl.auto` - Автоматически проверяет или экспортирует DDL схемы в базу данных когда SessionFactory создан. С помощью create-drop схема базы данных будет удалена когда SessionFactory будет закрыт явно.
***значения***: validate | update | create | create-drop

`hibernate.hbm2ddl.import_files` - Отделяемые запятыми имена необязательных файлов, содержащих SQL-выражения DML, выполняемые во время создания SessionFactory. Это полезно для тестирования или демонстрации: добавив инструкции INSERT, например, вы можете заполнить свою базу данных минимальным набором данных при ее развёртывании.

Порядок файлов имеет значение, операторы в файлах выполняются перед операциями следующих файлов. Эти инструкции выполняются если схема создана, т. е. если hibernate.hbm2ddl.auto настроен на create или create-drop.

***пример***: /humans.sql,/dogs.sql

`hibernate.hbm2ddl.import_files_sql_extractor` - Имя класса пользовательского ImportSqlCommandExtractor (по умолчанию используется встроенный SingleLineSqlCommandExtractor). Это полезно для реализации выделенного парсера, который извлекает отдельные инструкции SQL из каждого файла импорта. Hibernate предоставляет также MultipleLinesSqlCommandExtractor, который поддерживает инструкции/комментарии и цитируемые строки, распредёленные по нескольким строкам (обязательная точка с запятой в конце каждого оператора).

***пример***: classname.of.ImportSqlCommandExtractor

Итак, список возможных вариантов:
- validate : проверяет схему, не вносит изменений в базу данных, может проверить, совместимы ли сопоставления объектов JPA с базовой схемой базы данных.;
- update : обновляет схему, если схема отсутствует в БД, тогда схема создается;
- create : создает схему, уничтожая предыдущие данные;
- _create-drop_ : удалить схему, когда SessionFactory закрывается явно, обычно, когда приложение остановлено. схема не удаляется при закрытии сеанса. Он сбрасывается только при закрытии SessionFactory.
  
DDL — это язык определения данных : он используется для определения структур данных.
Например, в SQL это будут такие инструкции, как create table , alter table , ...

DML — это язык манипулирования данными : он используется для манипулирования самими данными.

Например, для SQL это будут такие инструкции, как insert , update , delete , ...

## 19. Требования JPA к Entity-классам? Не менее пяти.

1. Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации
JPA,
2. Entity класс должен содержать public или protected конструктор без аргументов (он также
может иметь конструкторы с аргументами),
3. Entity класс должен быть классом верхнего уровня (top-level class),
4. Entity класс не может быть enum или интерфейсом,
5. Entity класс не может быть финальным классом (final class),
6. Entity класс не может содержать финальные поля или методы, если они участвуют в
маппинге (persistent final methods or persistent final instance variables),
7. Если объект Entity класса будет передаваться по значению как отдельный объект (detached
object), например через удаленный интерфейс (through a remote interface), он так же должен
реализовывать Serializable интерфейс,
8. Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и
не должны быть напрямую доступны другим классам, использующим этот Entity. Такие
классы должны обращаться только к методам (getter/setter методам или другим методам
бизнес-логики в Entity классе),
9. Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов
которые уникально определяют запись этого Enity класса в базе данных

## 20. Жизненный цикл Entity в Hibernate? Рассказать. 

Persistence context - специальный контейнер, где объекты отслеживаются Hibernate.Объект в данном статусе — так называемая хранимая сущность, которая присоединена к конкретной сессии. Только в этом статусе объект взаимодействует с базой данных. При работе с объектом данного типа в рамках транзакции все изменения объекта записываются в базу. Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что _create-drop_ : удалить схему, когда SessionFactory закрывается явно, обычно, когда приложение остановлено. схема не удаляется при закрытии сеанса. Он сбрасывается только при закрытии SessionFactory. созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня. Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом.

Java-объекты сущности проходят через несколько состояний, когда их использует Hibernate:
- Transient(New) - состояние сущности, когда объект по сути только создан и еще не добвлен в базу/получен из нее(не имеет первичного сгенерированного ключа). Находится вне поля зрения Hibernate.
  
- Persistent(managed) - когда объект добавлен и транзакция закоммичена -> добавляется запись в БД и сущность отслеживается Hibernate. Это происходит, когда мы сохраняем объект в БД или достаем его из БД и помещаем в сущность. Объект отслеживается Hibernate до тех пор,пока не завершается сессия или пока вручную объект не выкидывается из Persistence context. При изменении состояния объекта в Persistance state Hibernate отслеживает изменение и генерирует SQL-код для изменения состояния соответствующей записи в БД. ==Все изменения отслеживаются в пределах транзакции! Только так Hibernate применит изменения к БД. ==
  
- Detached - состояние объекта, когда вызван метод .detached() или закрыта сессия, т.е. объект находится вне Persistance Context'a. Изменения не отслеживаются Hibernate, можно присоединить обратно с помощью .merge()

- Removed - объект помечен для удаления и следующий .commit() удаляет соответствующую
строку из таблицы.