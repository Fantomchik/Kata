- [1. Что такое потоки ввода-вывода? Как это реализовано в Java?](#1-что-такое-потоки-ввода-вывода-как-это-реализовано-в-java)
- [2. Что делает метод read?](#2-что-делает-метод-read)
- [3. Что такое System.in, что такое System.out?](#3-что-такое-systemin-что-такое-systemout)
- [4. Что делает flush?  Почему важно закрывать потоки?](#4-что-делает-flush--почему-важно-закрывать-потоки)
- [5. Расскажи про классы Reader и Writer?](#5-расскажи-про-классы-reader-и-writer)
- [6. Как преобразовать считанные байты в символы? Какой класс для этого используется?](#6-как-преобразовать-считанные-байты-в-символы-какой-класс-для-этого-используется)
- [7. Отличие Scanner’a от BufferedReader’a?](#7-отличие-scannera-от-bufferedreadera)
- [8. Отличие пакета io от nio?](#8-отличие-пакета-io-от-nio)
- [9. Расскажи про класс File? Как создать новый файл на жестком диске?](#9-расскажи-про-класс-file-как-создать-новый-файл-на-жестком-диске)
- [10. В чём отличие File от Path?](#10-в-чём-отличие-file-от-path)
- [11. В чем разница между абсолютным и относительным путем?](#11-в-чем-разница-между-абсолютным-и-относительным-путем)
- [12. Что такое клонирование? Как реализовано клонирование в Java?](#12-что-такое-клонирование-как-реализовано-клонирование-в-java)
- [13. Как удалить директорию с файлами?](#13-как-удалить-директорию-с-файлами)
- [14. В чём разница между поверхностным и глубоким клонированием? Как реализовать глубокое клонирование?](#14-в-чём-разница-между-поверхностным-и-глубоким-клонированием-как-реализовать-глубокое-клонирование)
- [15. Что такое сериализация и десериализация?](#15-что-такое-сериализация-и-десериализация)
- [16. Назовите несколько форматов сериализации.](#16-назовите-несколько-форматов-сериализации)
- [17. Какие поля не сериализуются?](#17-какие-поля-не-сериализуются)
- [18. Как сериализовать статическое поле?](#18-как-сериализовать-статическое-поле)
- [19. Что такое логирование? Для чего оно нужно? (ДОП) Какую информацию мы можем получить из лога? (ДОП)](#19-что-такое-логирование-для-чего-оно-нужно-доп-какую-информацию-мы-можем-получить-из-лога-доп)
- [20. Почему нельзя просто использовать sout?](#20-почему-нельзя-просто-использовать-sout)
- [21. Какие есть уровни логирования и для чего они нужны? (ДОП)Какой уровень логирования по умолчанию?](#21-какие-есть-уровни-логирования-и-для-чего-они-нужны-допкакой-уровень-логирования-по-умолчанию)
- [22. Сообщения каких уровней мы увидим, задав уровень INFO?](#22-сообщения-каких-уровней-мы-увидим-задав-уровень-info)
- [23. Обязательно ли передавать в метод getLogger() имя класса? Почему так принято?](#23-обязательно-ли-передавать-в-метод-getlogger-имя-класса-почему-так-принято)
- [24. В чем разница между throws и throw?](#24-в-чем-разница-между-throws-и-throw)


## 1. Что такое потоки ввода-вывода? Как это реализовано в Java?
Объект, из которого можно считать данные, называется потоком ввода, а объект, в который можно записывать данные, - потоком вывода.

В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода).
Для работы с потоками символов были добавлены абстрактные классы Reader (для чтения потоков символов) и Writer (для записи потоков символов).
Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов.

## 2. Что делает метод read?
Метод  read()  в Java используется для чтения данных из потока ввода. Он возвращает целочисленное значение, которое представляет собой символ, считанный из потока. Обычно этот метод вызывается на объекте класса  InputStream  или его производных классах. 
 
Например, если вы используете  FileInputStream  для чтения данных из файла, то метод  read()  будет читать данные из файла по одному байту за раз и возвращать целочисленное значение, представляющее считанный байт данных. Если достигнут конец файла, метод  read()  вернет значение -1.

## 3. Что такое System.in, что такое System.out?
Объекты считывания и вывода на консоль.
Стандартный поток ввода (клавиатура) в Java представлен объектом — System.in .А стандартный поток вывода (дисплей) — уже знакомым вам объектом System.out.

## 4. Что делает flush?  Почему важно закрывать потоки?
Вызов  flush()  принудительно записывает все данные из буфера в выходной поток. Это особенно полезно, когда важно, чтобы данные были видны в выходном потоке немедленно, например, когда вы работаете с сетевыми соединениями или когда программа завершается и нужно сохранить все данные. 

При закрытии потока освобождаются все выделенные для него ресурсы, например, файл. В случае, если поток окажется не закрыт, может происходить утечка памяти.ByteArrayOutputStream

## 5. Расскажи про классы Reader и Writer?
Класс  Reader  предоставляет методы для чтения символов из источника данных, например, из файла или сетевого соединения.
Класс  Writer  предоставляет методы для записи символов в приемник данных, например, в файл или сетевое соединение.

## 6. Как преобразовать считанные байты в символы? Какой класс для этого используется?
Для преобразования считанных байтов в символы вы можете использовать классы InputStreamReader  и  OutputStreamWriter.
- OutputStreamWriter — «мост» между классом OutputStream и классом Writer. Символы, записанные в поток, преобразовываются в байты.
- InputStreamReader — аналог для чтения. При помощи методов класса Reader читаются байты из потока InputStream и далее преобразуются в символы.

Используя полученный байтовый массив, мы можем преобразовать обратно в исходную строку, используя «классический» конструктор строки « новая строка (байт[]) »
Полученный байтовый массив создается путем приведения каждого символьного значения к его байтовому эквиваленту, поскольку мы знаем, что все символы находятся в диапазоне ASCII (0–127), поэтому могут занимать только один Байт в размере.

```
public static byte[] stringToBytesASCII(String str) {
		char[] buffer = str.toCharArray();
		byte[] b = new byte[buffer.length];
		for (int i = 0; i < b.length; i++) {
				b[i] = (byte) buffer[i];
		}
		return b;
}
```

## 7. Отличие Scanner’a от BufferedReader’a?
- BufferedReader является синхронным, а Scanner - нет. BufferedReader следует использовать, если мы работаем с несколькими потоками.
- BufferedReader имеет значительно больший объем буферной памяти, чем Scanner.
- У сканера небольшой буфер (1 КБ буфера символов) в отличие от BufferedReader (8 КБ байтового буфера), но этого более чем достаточно.
- BufferedReader работает немного быстрее по сравнению со Scanner, потому что сканер выполняет синтаксический анализ входных данных, а BufferedReader просто считывает последовательность символов.

## 8. Отличие пакета io от nio?
IO

1) Блокирующий ввод-вывод. 
   
Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.

2) Потокоориентированный ввод-вывод.

Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. Если вы хотите произвести подобные манипуляции, вам придется сначала кэшировать данные в буфере.

NIO

1) Неблокирующий ввод-вывод.
   
Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.

2) Буфероориентированный ввод-вывод.
   
3) Селекторы.
   
Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Можно зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.

## 9. Расскажи про класс File? Как создать новый файл на жестком диске?
Класс File, определенный в пакете java.io, не работает напрямую с потоками. Его задачей является управление информацией о файлах и каталогах. Хотя на уровне операционной системы файлы и каталоги отличаются, но в Java они описываются одним классом File.

boolean createNewFile(): создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает true, иначе false.

## 10. В чём отличие File от Path?
File — это класс Path — это интерфейс.
Методы работы с ФС через объект Path при ошибках ввода-вывода бросают исключения; методы работы с File при ошибках возвращают false.
File — это старый способ доступа к файловой системе
Path — это новый рекомендуемый способ. Path допускает работу с файлами на виртуальных файловых системах, а File нет.

## 11. В чем разница между абсолютным и относительным путем?
Основное отличие между абсолютным и относительным путем в Java заключается в том, что абсолютный путь указывает на конкретное местоположение файла или директории от корневого каталога, в то время как относительный путь указывает на местоположение относительно текущего рабочего каталога. 
 
Абсолютный путь к файлу - это полный путь к файлу, начиная с корневого каталога файловой системы. Например, в Windows это может быть что-то вроде `C:\Users\Имя_пользователя\Documents\file.txt`, а в UNIX-подобных системах - `/home/имя_пользователя/documents/file.txt`. 
 
Относительный путь к файлу - это путь к файлу относительно текущего рабочего каталога. Например, если текущий каталог - `C:\Users\Имя_пользователя`, относительный путь к файлу `file.txt` будет выглядеть как `Documents\file.txt` в Windows и `documents/file.txt` в UNIX-подобных системах. 
 
Канонический путь к файлу - это абсолютный путь к файлу, который был нормализован и устранены все символические ссылки, сокращения и лишние символы. Например, канонический путь к файлу `C:\Users\Имя_пользователя\Documents\..\file.txt` может быть `C:\Users\Имя_пользователя\file.txt` в Windows и `/home/имя_пользователя/file.txt` в UNIX-подобных системах.

## 12. Что такое клонирование? Как реализовано клонирование в Java?
Клонирование — это создание копии исходного объекта. Его словарное значение: «сделать идентичную копию».

По умолчанию клонирование Java выполняется «копированием поля за полем», поскольку класс Object не имеет никакого представления о структуре класса, в котором будет вызываться метод clone().

В первую очередь необходимо реализовать интерфейс Cloneable. Если этого не сделать, при вызове метода clone() выбросится исключение CloneNotSupportedException. Интерфейс Cloneable является маркерным, то есть не имеет ни одного метода. Он показывает что объекты класса могут быть клонированы. Метод clone() является protected, поэтому класс может клонировать только собственные объекты. Для того, чтобы клонировать другие объекты, метод clone() нужно расширить до public.

## 13. Как удалить директорию с файлами?
Необходимо воспользоваться методом delete(Path path) класса Files.
Пример кода: Files.delete(Path.of(“c:\\desktop));
Директория будет удалена только если она пустая.
Вложенные директории удаляются с помощью рекурсии.

Для удаления файлов или папок в Java используется метод java.io.File delete(). Он возвращает true , если файл удалился успешно и возвращает false , если указанный для удаления файл не существует или не может быть удален.

1) Files.delete(Path path) - удаляет файл или папку. Может бросить NoSuchFileException или DirectoryNotEmptyException.

2) Files.deleteIfExists() - удаляет файл или папку. В случае проблем просто возвращает false.

## 14. В чём разница между поверхностным и глубоким клонированием? Как реализовать глубокое клонирование?
1. При глубоком копирование новый объект хранит копии значений объекта, тогда как при поверхностным копирование новый объект хранить ссылки на исходный адрес памяти.
2. Глубокая копия не отражает изменения, внесенные в новый/скопированный объект в исходном объекте; в то время как поверхностная копия отражает.

## 15. Что такое сериализация и десериализация?
Сериализация это процесс сохранения состояния объекта в последовательность байт; десериализация это процесс восстановления объекта, из этих байт.

Java Serialization API предоставляет стандартный механизм для создания сериализуемых объектов. Процесс сериализации заключается в сериализации каждого поля объекта, но только в том случае, если это поле не имеет спецификатора static или transient. Поля, помеченные ими не могут быть предметом сериализации.
`transient` — это модификатор, указываемый перед полем класса (подобно другим модификаторам, таким как public, final и т.д.) для обозначения того, что данное поле не должно быть сериализовано. 

## 16. Назовите несколько форматов сериализации.
1. `JSON` (JavaScript Object Notation) - это популярный формат сериализации, основанный на синтаксисе JavaScript. Он широко используется для обмена данными между клиентом и сервером. 
 
2. `XML` (eXtensible Markup Language) - это формат сериализации, который использует разметку для представления данных. Он также широко применяется для обмена данными между системами. 
 
3. `YAML` (YAML Ain't Markup Language) - это формат сериализации, который облегчает читаемость человеком. Он широко используется в конфигурационных файлах и структурированных данных. 

4. `BSON` (Binary JSON) - это бинарный формат сериализации данных, который является расширением JSON. Он обеспечивает более эффективное хранение и передачу данных.

## 17. Какие поля не сериализуются?
1. При стандартной сериализации поля, имеющие модификатор static, не сериализуются. Соответственно, после десериализации это поле значения не меняет. 
2. Поля, помеченные атрибутом "transient"

## 18. Как сериализовать статическое поле?
При использовании реализации Externalizable сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.

## 19. Что такое логирование? Для чего оно нужно? (ДОП) Какую информацию мы можем получить из лога? (ДОП)
Логирование - это процесс записи информации о работе программы или системы в лог-файлы. Главная цель логирования состоит в том, чтобы предоставить информацию о состоянии и поведении программы во время выполнения.

1. Сообщения об ошибках: о возникших ошибках, исключениях и стеке вызовов, что помогает идентифицировать и исправить проблемы в программе.  
2. Предупреждения  о потенциальных проблемах или неправильном использовании программы, которые могут потребовать внимания или корректировки. 
3. Информационные сообщения: информацию о процессе выполнения программы, например, о старте или остановке процессов, выполнении определенных операций или достижении определенных условий. 
4. Данные о производительности: информацию о времени выполнения определенных операций, использовании ресурсов (например, памяти или процессора) и других метриках производительности, что позволяет анализировать и оптимизировать работу программы. 
5. Аудит и безопасность: информацию о действиях пользователей, доступе к ресурсам, аутентификации и других событиях, которые могут быть полезны для обнаружения и реагирования на потенциальные угрозы безопасности или аудита системы. 
6. Статистика и аналитика: данные для анализа поведения пользователей, сбора статистики и получения информации о том, как используется программа или система. 

## 20. Почему нельзя просто использовать sout?
1. Недостаток контроля: Использование  System.out.println()  не предоставляет механизмов для контроля формата вывода или уровней логирования. Вы не можете легко настроить его для вывода только определенных сообщений или изменить формат вывода без изменения кода. 
2. Неэффективность: Каждый вызов  System.out.println()  может быть затратным с точки зрения производительности, особенно если он вызывается часто или в критических участках кода. Вывод в консоль может замедлить работу программы. 
3. Неудобство при отладке в продуктивной среде: В продуктивной среде, где необходимо отслеживать и анализировать большое количество логов, использование  System.out.println()  становится неудобным и неэффективным. 
 
Вместо использования  System.out.println()  рекомендуется использовать специализированные библиотеки логирования, такие как Log4j, SLF4J или java.util.logging. Эти библиотеки предоставляют более гибкие и эффективные инструменты для логирования, позволяя контролировать уровни логирования, формат вывода, перенаправление логов в файлы и другие функции, которые облегчают анализ и управление логами в приложении.

## 21. Какие есть уровни логирования и для чего они нужны? (ДОП)Какой уровень логирования по умолчанию?
1. `FATAL` (критическая ошибка): Самый высокий уровень логирования, используемый для сообщений о критических ошибках, которые приводят к аварийному завершению программы или серьезным проблемам в системе.   
2. `ERROR` (ошибка): Уровень логирования, используемый для сообщений об ошибках, которые приводят к некорректной работе программы или ведут к исключительным ситуациям.
3. `WARN` (предупреждение): Уровень логирования, который указывает на потенциально проблемные ситуации или нежелательные события, которые не являются критическими, но требуют внимания. 
4. `INFO` (информация): Уровень логирования, предназначенный для информационных сообщений, которые помогают отслеживать ход работы программы и сообщать о важных событиях. - уровень по умолчанию
5. `DEBUG` (отладка): Уровень логирования, используемый для вывода отладочной информации, которая помогает в поиске ошибок и проверке работы программы. 
6. `TRACE` (след): Самый низкий уровень логирования. Используется для трассировки выполнения программы и вывода подробных сообщений для отладки. 
 
Уровни логирования позволяют настроить, какие сообщения будут записаны в логи, а какие будут проигнорированы. Это помогает в анализе и отладке приложений, а также в мониторинге и обнаружении проблем в работе системы. Уровни логирования также могут быть настроены для вывода сообщений в различные цели, такие как консоль, файлы логов или базы данных.

`По умолчанию используется уровень info`, который используется для описания ключевых и важных вещей. При таком уровне будут выводиться и warning, и error.

## 22. Сообщения каких уровней мы увидим, задав уровень INFO?
Все, что выше INFO. При задании уровня логирования на INFO мы увидим сообщения с уровнями INFO, WARNING, ERROR и FATAL.

## 23. Обязательно ли передавать в метод getLogger() имя класса? Почему так принято?
Обычно передача имени класса в метод getLogger() является хорошей практикой при настройке логирования. Когда вы передаете имя класса, вы можете легко определить, откуда было вызвано определенное сообщение лога. Это особенно полезно в больших проектах с множеством классов и модулей, где логирование служит для отладки и мониторинга приложения.

## 24. В чем разница между throws и throw?
`throw` используется для генерации исключения внутри метода, а `throws` используется для объявления возможных исключений, которые может сгенерировать метод.