1. Что такое generic и для чего они нужны?
   Дженерики (или обобщения) - это параметризованные типы. Параметризованные типы позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра. Например, используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных.
2. Что такое wildcard?
   Wildcard — (сильная карта или символом подстановки) это дженерик, обозначается вопросительным знаком в угловых скобках <?>, означает, что тип может быть чем угодно.
3. Где используется wildcard?
   Wildcard может использоваться при создании коллекций List<?> exp = new ArrayList<String>(); В параметрах и типе возвращаемого значения метода List<?> expMethod(List <?> e);
4. Как используется wildcard?
   Wldcard позволяет подставить любой тип вместо символа <?>
5. Что такое принцип PECS?
   Producer Extends Consumer Super - Поставщик расширяет, потребитель ограничивает. Это означает, что типы используемые в wildcard можно ограничивать сверху и снизу по иерархии. Также называется Bounded Wildcards.
6. Принцип PECS более подробно?
   Для ограничения используется <? extends T> и <? super T>. <? extends T> - означает что можно использовать всех наследников от типа Т и сам тип Т включительно. <? super T> - означает что можно использовать только предков типа Т и сам тип Т включительно.
7. Принцип PECS еще?
   <? extends Number> - означает что можно использовать Integer, Long, Double и все что наследуется от Number. Допустим есть класс Car и его наследник Car1 и наследник от Car1 класс Car2. <? super Car1> - означает что можно использовать сам класс Car1 и класс Car. Т.е. можно использовать только предков.
8. Upper Bounded Wildcards, Lower Bounded Wildcards?
   Аналогично PECS. Upper Bounded Wildcards - extends T. Lower Bounded Wildcards - super T.
9.  Что такое raw type?
    Raw type (сырые типы) это generic-типы без указания типа-параметра. Например: List listRawType = new ArrayList(); В один лист можно добавить объекты разного типа, например, Integer и String.
10. Какие проблемы могут быть при использовании raw type?
    Raw type использовать настоятельно не рекомендуется. Он нужен для обратной совместимости. До появления generic в Java 5. При использовании возможна проблема heap pollution - ошибка когда переменная параметризованного типа хранит в себе объект, параметризованный другим типом.
11. В чем отличие ArrayList и ArrayList<?> ?
    ArrayList - без указания типа использует raw type. ArrayList<?> Это лист без конкретного параметра, в него нельзя ничего добавить кроме null. Но его можно использовать например в параметре метода и принимать различные типы листа.
12. Что такое Type Erasure (стирание типов)?
    Информация о типе параметра дженерика во время компиляции заменяется на Object. При необходимости добавляется явное приведение типов.
13. Что такое коллекции в Java?
    Коллекции в Java это классы, основная цель которых - хранить набор других элементов. Коллекции — это наборы однородных элементов.
14. Преимущества использования коллекций?
    - Сокращение усилий по разработке благодаря использованию базовых классов коллекций, а не реализации собственных классов коллекций.
    - Качество и безопасность кода улучшается за счет использования хорошо протестированных базовых классов коллекций.
    - Возможность повторного использования и обратная совместимость с прошлыми версиями Java.
    - Поддержка многопоточного доступа.
    - Возможность динамического увлечения размера в отличии от массивов.
15. С чем работают коллекции а с чем массивы?
    Коллекции работают с объектами и могут хранить любые ссылочные типы данных. Массивы могут работать с примитивами.
16. Какова иерархия коллекций?
    На вершине иерархии в Java Collections Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).
17. Основные коллекции интерфейса Collection?
    Set, List, Queue
18. Основные коллекции интерфейса Map?
    HashMap, LinkedHashMap, TreeMap, Hashtable
19. Что вы знаете о коллекциях типа List?
    List — это упорядоченный список. Объекты хранятся в порядке их добавления в список. Доступ к элементам списка осуществляется по индексу.
20. Что вы знаете о коллекциях типа Set?
    Set — неупорядоченное множество уникальных (неповторяющихся) объектов. В коллекции этого типа разрешено наличие только одной ссылки типа null.
21. Что вы знаете о коллекциях типа Queue?
    Кью - Очередь. Этот список, который используется для реализации концепции FIFO (first in, first out) — «первым пришёл — первым ушёл». В Queue элементы обычно добавляются в конец.
22. Что вы знаете о коллекциях типа Deque?
    .Дек - двунаправленая очередь. Расширяет интерфейс Queue. Обычно используется для реализации концепции LIFO (last in - first out) - "последний пришёл первый вышел" или как Stack. Но может выступать роли обычной очереди. Можно добавлять элементы как в начало, так и в конец очереди. Интерфейс Deque позиционируется как современная альтернатива классу Stack.
23. Что вы знаете о коллекциях типа Stack?
    Стек - это подкласс Vector, который реализует стандартный стек LIFO. Рекомендуется использовать Deque в место Stack.
24. Почему Map не наследуется от Collection?
    Map не наследуется от Collection, потому что это разные структуры данных.
25. Что вы знаете о коллекциях типа HashMap?
    HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка элементов с течением времени. Разрешение коллизий осуществляется с помощью метода цепочек.
26. Как устроен HashMap?(часть 1)
    Вычисляется хэш ключа. Если ключ null, хэш считается равным 0. Чтобы достичь лучшего распределения, результат вызова hashCode() «перемешивается»: его старшие биты XOR-ятся на младшие.
27. Как устроен HashMap?(часть 2)
    Значения внутри хэш-таблицы хранятся в специальных структурах данных - нодах, в массиве. Из хэша высчитывается номер бакета - индекс для значения в этом массиве. Полученный хэш обрезается по текущей длине массива. Длина - всегда степень двойки, так что для скорости используется битовая операция &
28. Как устроен HashMap?(часть 3)
    В бакете ищется нода. В ячейке массива лежит не просто одна нода, а связка всех нод, которые туда попали. Исполнение проходит по этой связке (цепочке или дереву), и ищет ноду с таким же ключом. Ключ сравнивается с имеющимися сначала на == (ссылке), затем на equals.
29. Как устроен HashMap?(часть 4)
    Если нода найдена - её значение просто заменяется новым. Работа метода на этом завершается.
30. Как устроен HashMap?(часть 5)
    Если ноды с таким же ключом в бакете пока нет - добавляемая пара ключ-значение запаковывается в новый объект типа Node, и прикрепляется к структуре существующих нод бакета. Ноды составляют структуру за счет того, что в ноде хранится ссылка на следующий элемент (для дерева - следующие элементы). Кроме самой пары и ссылок, чтобы потом не считать заново, записывается и хэш ключа.
31. Как устроен HashMap?(часть 6)
    В случае, когда структурой была цепочка а не дерево, и длина цепочки превысила 7 элементов - происходит процедура treeification - превращение списка в самобалансирующееся дерево. В случае коллизии это ускоряет доступ к элементам на чтение с O(n) до O(log(n)). У comparable-ключей для балансировки используется их естественный порядок. Другие ключи балансируются по порядку имен их классов и значениям identityHashCode-ов. Для маленьких хэш-таблиц (< 64 бакетов) «одеревенение» заменяется увеличением (см. п.8).
32. Как устроен HashMap?(часть 7)
    Если новая нода попала в пустую ячейку, заняла новый бакет - увеличивается счетчик структурных модификаций. Изменение этого счетчика сообщит всем итераторам контейнера, что при следующем обращении они должны выбросить ConcurrentModificationException.
33. Как устроен HashMap?(часть 8)
    Когда количество занятых бакетов массива превысило пороговое (capacity * load factor), внутренний массив увеличивается вдвое, а для всего содержимого выполняется рехэш - все имеющиеся ноды перераспределяются по бакетам по тем же правилам, но уже с учетом нового размера.
34. Чем отличается метод Put и Get для HashMap?
    Put вставляет новый элемент в ноду или перезаписывает имеющийся. Метод Get позволяет получить имеющуюся пару, тем же образом что и запись, только без добавления.
35. Как решается коллизия HashMap?
    При совпадении хеш кода, объект сравнивается на равенство ссылок а затем по equals. Если Совпадение найдено то значение у ключа перезаписывается. Если не найдено, то создается новая нода и прикрепляется к структуре существующих нод бакета.
36. Чем отличается Map от HashMap?
    Map это интерфейс, HashMap это реализация этого интерфейса.
37. Условия перестроения в красно-черное дерево (одеревенение) HashMap?
    Как только длина связного списка переходит превышает 7 элементов происходит процедура treeification - превращение списка в самобалансирующееся дерево. Для маленьких хэш-таблиц (< 64 бакетов) «одеревенение» заменяется увеличением.
38. В чем отличие Map от Set?
    Map состоит из пар «ключ-значение». Ключи уникальны, а значения могут повторяться. Порядок элементов не гарантирован. Может иметь 1 null ключ и несколько null значений.
    Set состоит из ключей. Которые должны быть уникальны. В HashSet элементы не упорядочены и хранятся в удобном для HashSet порядке (можно сказать случайном). Может хранить 1 null значение.
39. Что вы знаете о коллекциях типа HashSet?
    Хеш сет представляет собой таблицу хеш кодов, которая генерируется при добавлении элемента. Элементами хеш сета могут быть только уникальные значения ключа, и одно null значение.
40. Как работает HashSet?
    HashSet основан на HashMap, и так же представляет собой массив. HashSet использует хеш таблицы. В начале вычисляется хеш код объекта. На основании хеша и размера массива вычисляется индекс массива. По этому индексу кладется объект. Если происходит коллизия ( эта ячейка не пустая), то в эту же ячейку ложится новый объект и используется односвязный список между ними.
41. Что в HashSet используется вместо значений HashMap?
    new Object.
42. Почему в HashSet используется new Object а не null для value значений?
    Если не использовать null значение, то при создании и удалении элементов, не будет видно выполнилось действие или нет, т.к. до и после ссылка будет равна null.
43. Что вы знаете о коллекциях типа TreeSet?
    TreeSet — коллекция, которая хранит свои элементы вв отсортированном и возрастающем порядке. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно-черное дерево для хранения элементов. TreeSet хорош тем, что для операций add, remove и contains потребуется гарантированное время log(n).
44. Что вы знаете о коллекциях типа TreeMap?
    - Имплементирует интерфейсы NavigableMap и SortedMap, TreeMap получает дополнительный функционал, которого нет в HashMap, но с меньшей производительностью.
    - В TreeMap элементы хранятся в естественном(по возрастанию) порядке или согласно компаратору.
    - В основе лежит Красно-чёрное дерево (Red-Black Tree).
    - Возможность работы с null-ключом если он разрешен компаратором.
45. Что такое красно-черное дерево?
    Структура для хранения данных. Если в кратце, то у любого дерева есть корень. Если нужное значение меньше чем корень, то поиск идет в левой части, если больше то в правой.
46. Что вы знаете о коллекциях типа LinkedHashSet?
    LinkedHashSet наследуется от HashSet. Храненит элементы в порядке добавления. Имеет двухсвязный список между элементами.
47. Что вы знаете о коллекциях типа LinkedHashMap?
    LinkedHashMapнаследуется от HashMap. Храненит элементы в порядке добавления. Имеет двухсвязный список между элементами.
48. На что указывают крайние ссылки в двухсвязном списке?
    на null
49. Что такое двухсвязный и односвязный список?
    двухсвязный список - когда элемент имеют ссылку на предыдущий и следующий. односвязный список - когда элемент имеют ссылку на следующий.
50. Основные реализации List?
    - ArrayList Список
    - LinkedList Список
    - Vector Вектор
    - Stack Стек
51. Основные реализации Set?
    - HashSet
    - TreeSet
    - LinkedHashSet
52. Основные реализации Map?
    - HashMap
    - TreeMap
    - LinkedHashMap
    - Hashtable
53. Что вы знаете о коллекциях типа LinkedList?
    LinkedList - реализует интерфейс List. Является двунаправленным списком, где каждый элемент структуры содержит указатели на предыдущий и следующий элементы. Итератор поддерживает обход в обе стороны. Реализует методы получения, удаления и вставки в начало, середину и конец списка. Позволяет добавлять любые элементы в том числе и null. Хранит Элементы в порядке добавления.
54. Какие реализации SortedSet вы знаете и в чем их особенность?
    TreeSet - реаализации SortedSet. Реализации этого интерфейса, следит за уникальностью хранимых объектов и поддерживают их в порядке возрастания. Отношение порядка между объектами может быть определено, помощью метода compareTo интерфейса Comparable<T>, или при помощи специального класса-компаратора, наследующего интерфейс Comparator<T>.
55. В чем отличия/сходства List и Set?
    Оба унаследованы от Collection, а значит имеют одинаковый набор и сигнатуры методов. List хранит объекты в порядке вставки, элемент можно получить по индексу. Set не может хранить одинаковых элементов, доступ по ключу.
56. Что разного/общего у классов ArrayList и LinkedList?
    ArrayList реализован внутри в виде обычного массива, доступ по индексу и вставка в конец происходит очень быстро. Для вставки в середину или начало приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. LinkedList реализован в виде двухсвязного списка. Каждый элемент знает предыдущий и следующий за ним. Вставка осуществляется быстро за счет простого изменения ссылок на соседние элементы. А обход по всем элементам занимает много времени.
57. Когда лучше использовать ArrayList, а когда LinkedList?
    Часто указывается что там где нужно добавлять и удалять много элементов из середины нужно использовать LinkedList. А там где нужен доступ по индексу и добавление в конец - ArrayList. Но по факту лучше стараться почти всегда использовать ArrayList. Т.к в большинстве случаев LinkedList проигрывает по потребляемой памяти и по скорости выполнения операций ArrayList. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.
58. Что будет, если в Map положить два значения с одинаковым ключом?
    Последнее значение перезапишет предыдущее.
59. Что такое HashtTable, чем она отличается от HashMap?
    HashtTable- deprecated. Не рекомендована к использованию. Основные отличия HashtTable - синхронизирована и медленнее работает и не позволяет иметь null ключей и значений.
60. Порядок следования в коллекциях?
    - HashMap/HashSet - "случайный" порядок(удобный для Map/Set) хранения элементов.
    - ТгееМар/ТгееSet - хранит эл-ты в порядке возрастания элементов.
    - LinkedHashMap/LinkedHashSet - хранит эл-ты в порядке добавления элементов.
61. Дайте определение понятию "итератор"?
    Iterator<E> iterator() это метод интерфейса Collection. Он возвращает итератор — то есть объект, реализующий интерфейс Iterator. Итератор — объект, позволяющий перебирать элементы коллекции.
62. Методы Iterator?
    - next();
    - boolean hasNext();
    - void remove();
63. Какую функциональность представляет класс Collections?
    - Collections.sort() - cсортировка
    - Collections.shuffle() - Перемешивает коллекцию в случайном порядке.
    - Collections.reverse() - Переворачивает коллекцию в обратном порядке.
    - Collections.binarySearch() - Поиск в коллекции по ключу с использованием бинарного поиска.
    - Collections.copy() - Копирует коллекцию источник src в dest.
    - Collections.frequency() - Возвращает число вхождений объекта в коллекции.
    - Collections.synchronizedCollection() - Возвращает синхронизированную (потокобезопасную) коллекцию.
64. Какие коллекции синхронизированы?
    Для этого используется пакет Concurrent. @Deprecated HashTable, Vector.
65. Как получить синхронизированную коллекцию из не синхронизированной?
    - Collections.synchronizedList(list);
    - ollections.synchronizedSet(set);
    - Collections.synchronizedMap(map);
Все они принимают коллекцию в качестве параметра, и возвращают потокобезопасную коллекцию с теми же элементами внутри.
1.   Как получить коллекцию только для чтения?
    - Collections.unmodifiableList(list);
    - Collections.unmodifiableSet(set);
    - Collections.unmodifiableMap(map);
Все они принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.
1.   В чем разница между Iterator и Enumeration?
  Enumeration в два раза быстрее Iterator и использует меньше памяти. Iterator потокобезопасен, т.к. не позволяет другим потокам модифицировать коллекцию при переборе.  Enumeration можно использовать только для read-only коллекций. Так же у него отсутствует метод remove();
1.  Разница между Iterator и Iterable?
    - Iterable - это простое представление серии элементов, которые могут быть итерированы поверх. У него нет никакого состояния итерации такого как "текущий элемент". Вместо этого у него есть один метод, который производит Iterator.
    - Iterator - это объект с состоянием итерации. Он позволяет проверить, есть ли у него больше элементов с помощью hasNext() и переместиться на следующий элемент (если есть) с помощью next(). И метод Remove.
2.  Зачем в итераторе метод remove?
    Для удаления элемента из коллекции при обходе;Перед этим необходимо вызвать метод next(). Для того что бы перейти на элемент который нужно удалить.
3.  В чем разница между Iterator и ListIterator?
    Iterator может использоваться для перебора любых коллеций Set, List и Map. В отличие от него, ListIterator может быть использован только для перебора элементов коллекции List. Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). И удалять методом remove() Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous(), модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove().
4.  Какие есть способы перебора всех элементов List?
    Iterator, listIterator, for, forEach,While
5.  В чём различие между fail-fast и fail-safe итераторами?
    Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe - нет.
6.  Что делать, чтобы не возникло исключение ConcurrentModificationException?
    Можно подобрать другой итератор, работающий по принципу fail-safe. К примеру, если вы используете List, то можете взять ListIterator. Если же вам нужна устаревшая коллекция — то используйте перечислители. В том случае, когда вышеизложенное вам не подходит, у вас есть три варианта:
    - При использовании JDK 1.5 или выше, вам подойдут классы ConcurrentHashMap и CopyOnWriteArrayList. Это самый лучший вариант
    - Вы можете преобразовать список в массив и перебирать массив
    - Вы можете блокировать изменения списка на время перебора с помощью блока synchronized.
    Обратите внимание, что последние два варианта негативно скажутся на производительности.
7.  Как реализован цикл foreach?
    Реализован на основе Iterator.
8.  Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?
    Итератор похож на указатель своими основными операциями: он указывает на отдельный элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции для перехода к другому элементу списка (следующему или предыдущему).Контейнер, который реализует поддержку итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны ли все элементы контейнера (является ли итератор конечным).Таким образом без курсора просто нельзя будет реализовать безошибочное передвижение по коллекции.
9.  В чем разница между интерфейсами Comparable и Comparator?
    Коротко:
    - Comparable используется для естественной сортировки(по возрастанию).
    - Comparator для сортировки по разным шаблонам.

    Подробно:
    Классы-обертки как Integer, Double и String реализуют интерфейс Comparable. По этому метод sort ,без параметров может сортировать эти объекты.
    Интерфейс Comparable может быть реализован именно элементами коллекции или ключами Map.
    Так же интерфейсом Comparable может пользоваться любой класс который его реализует и переопределяет.

    Если у вас нет доступа к классу можно реализовать интерфейс Comparator.

    Comparator реализуется отдельным объектом (это удобно, так как можно заготовить несколько реализаций для разных правил сортировок, не меняя при этом код элементов коллекции/ключей Map).
10. Почему коллекции не наследуют интерфейсы Cloneable и Serializable?
    Клонирование и сериализация являются очень узкоспецифичными операциями, и реализовывать их нужно только когда это необходимо. Так же каждая операция клонирования потребляет очень много памяти, и неопытные программисты могут расходовать ее сами не понимая последствий.
11. Что можно параметризовать?
    Параметризовать можно классы, конструкторы, методы, интерфейсы, поля.
12. Параметризация статических переменных и методов?
    Нельзя создавать обобщенные статические переменные и методы. Можно объявлять статические методы со своими параметрами(отличающимися от параметров класса)
13. Ограничения присущие обобщениям?
    - Нельзя создавать экземпляр по параметру типа. Ни обычный объект, ни массив. Тип экземпляра класса должен быть известен заранее.
    - Нельзя создать массив специфических для типа обобщенных ссылок
    - Нельзя создавать обобщенные статические переменные и методы.
14. Почему в статические методы не передается тип класса?
    Если статический метод будет привязан к параметрам класса, то может возникнуть такая ситуация, когда экземпляра класса еще не было создан. Так же и со статическими полями и параметрами класса.
15. Как параметризовать статический метод?
    статический метод параметризуется так же как и обычный - перед типом возвращаемого значения указывается параметр в угловых скобках <T>.
16. Что такое даймонд оператор?
    Это треугольные скобки <>. Даймонд оператор Уменьшает количество кода при использовании дженериков. При создании объекта слева пишется его тип, а с права уже не нужно повторять этот тип, оператор можно оставить пустым.(возможно не для анонимного метода, но это не точно)
17. Почему последняя строчка не скомпилируется?
    ```
    List<ArrayList> al = new ArrayList<ArrayList>();
    ArrayList<List> al = new ArrayList<ArrayList>();
    ```
    Потому что дженерики инварианты.
    Т.е. нельзя приводить конкретный тип к общему.
    List<ArrayList> - ArrayList<ArrayList> это частный случай List и по этому его можно создать.
    ArrayList<List> - ArrayList<ArrayList> создать нельзя. Наследование исходных типов не переносится на производные.

1.  Что такое ковариантность и контравариантность?
    Формально, ковариантность/контравариантность типов - это сохранение/обращение порядка наследования для производных типов. Проще говоря, когда у ковариантных сущностей типами-параметрами являются родитель и наследник, они сами становятся как бы родителем и наследником. Контравариантные наоборот, становятся наследником и родителем.
2.  Что такое инвариантность?
    Инвариантность - это отсутствие свойств ковариантности и контрвариантности. Дженерики без вайлдкардов инвариантны: List<Number> нельзя положить ни в переменную типа List<Double>, ни в List<Object>. Массивы ковариантны: в переменную Object[] можно присвоить значение типа String[].
3.  Инвариантность еще раз?
    Инвариантность — ситуация, когда наследование исходных типов не переносится на производные. В List<Number> нельзя присвоить ничего кроме List<Number> не List<Integer> не List<Double>. Отношение предок-родитель не работает. Это сделано для типобезопасности.
4.  Всегда ли Generics инварианты?
    Нет. только без использования Wildcards.
5.  Что возвращает Comparator и Comparable?
    - 0 если объекты равны.
    - -1 (отрицательное число) если сравниваемый объект(1 объект) меньше передаваемого(2го объекта)
    - 1 (положительное число) если сравниваемый объект(1 объект) больше передаваемого(2го объекта)
6.  Какой метод у Comparator и Comparable?
    - public int compare(Person a, Person b)
    - public int compareTo(Person p)
7.  Что вернет HashMap если такое значения нет?
    Вернет null
8.  Какой метод у Iterable?
    Интерфейс Iterable содержит один метод iterator(), возвращающий объект типа Itaretor<E>.
9.  Можно ли удалить элемент через remove во время обхода коллекции?
    Нет. Можно удалить через Iterator.remove();
    
    
  
    