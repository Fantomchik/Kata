- [1.Что такое ветки GIT? Для чего они нужны?](#1что-такое-ветки-git-для-чего-они-нужны)
- [2.В чем отличие реляционной и нереляционной БД?](#2в-чем-отличие-реляционной-и-нереляционной-бд)
- [3.ACID?](#3acid)
- [4.Виды первичных ключей?](#4виды-первичных-ключей)
- [5.Что такое JDBC? Какие классы относятся к нему?](#5что-такое-jdbc-какие-классы-относятся-к-нему)
- [6.Что такое Statement, PreparedStatement?  В чем их отличие?](#6что-такое-statement-preparedstatement--в-чем-их-отличие)
- [7.В чем отличие классов-наследников и вложенных/внутренних классов?](#7в-чем-отличие-классов-наследников-и-вложенныхвнутренних-классов)
- [8.Параметры для автоматической генерации БД на основе сущностей, hbm2ddl.auto?](#8параметры-для-автоматической-генерации-бд-на-основе-сущностей-hbm2ddlauto)


## 1.Что такое ветки GIT? Для чего они нужны?
В Git ветки — это элемент повседневного процесса разработки. По сути, они представляют собой указатель на снимок изменений. Если нужно добавить новую возможность или исправить баг (незначительный или серьезный), вы создаете новую ветку, в которой будут размещаться эти изменения.
***Что такое ветка в репозитории?***
Ветки в Git представляют собой указатель на коммит. Если нужно добавить какую-то фичу или исправить баг (незначительный или серьезный), мы создаём новую ветку. Она будет содержать все изменения, которые мы хотим добавить в репозиторий.

Зачем в Git используются ветки?
Git Branch | Atlassian Git Tutorial
Ветки Git фактически являются указателем на снимок ваших изменений . Когда вы хотите добавить новую функцию или исправить ошибку — неважно, насколько она большая или маленькая — вы создаете новую ветку, чтобы инкапсулировать ваши изменения.

## 2.В чем отличие реляционной и нереляционной БД?
В реляционных базах данных структурированные данные хранятся в строках и столбцах на базе правил. В базах данных NoSQL хранятся отдельные элементы данных в отдельных файлах.

## 3.ACID?

В компьютерных науках ACID (атомарность, непротиворечивость, изоляция, устойчивость) то есть (atomicity, consistency, isolation, durability)  — это набор свойств транзакций базы данных, призванных гарантировать достоверность данных, несмотря на ошибки, сбои питания и другие сбои. В контексте баз данных последовательность операций с базой данных, удовлетворяющая свойствам ACID (которые можно рассматривать как одну логическую операцию над данными), называется транзакцией. Например, перевод средств с одного банковского счета на другой, даже включающий несколько изменений, таких как дебетование одного счета и зачисление на другой, является одной транзакцией.
***Атомарность (системы баз данных)***
Транзакции часто состоят из нескольких операторов. Атомарность гарантирует, что каждая транзакция рассматривается как отдельная «единица», которая либо полностью завершается успешно, либо полностью терпит неудачу: если какое-либо из операторов, составляющих транзакцию, не завершается, вся транзакция завершается неудачно, а база данных остается неизменной. Атомарная система должна гарантировать атомарность в любой ситуации, включая сбои питания, ошибки и сбои.Гарантия атомарности предотвращает только частичное обновление базы данных, что может вызвать более серьезные проблемы, чем полное отклонение всей серии. Как следствие, другой клиент базы данных не может наблюдать выполнение транзакции. В один момент времени это еще не произошло, а в следующий уже произошло целиком (или ничего не произошло, если транзакция была отменена в процессе).
***Согласованность (системы баз данных)***
Непротиворечивость гарантирует, что транзакция может перевести базу данных только из одного допустимого состояния в другое, поддерживая инварианты базы данных: любые данные, записанные в базу данных, должны быть действительными в соответствии со всеми определенными правилами, включая ограничения, каскады, триггеры и любую их комбинацию. Это предотвращает повреждение базы данных нелегальной транзакцией, но не гарантирует правильность транзакции. Ссылочная целостность гарантирует отношение первичного ключа к внешнему ключу.
***Изоляция (системы баз данных)***
Транзакции часто выполняются одновременно (например, несколько транзакций одновременно читают и пишут в таблицу). Изоляция гарантирует, что параллельное выполнение транзакций оставляет базу данных в том же состоянии, которое было бы получено, если бы транзакции выполнялись последовательно. Изоляция — основная цель управления параллелизмом; в зависимости от используемого метода последствия незавершенной транзакции могут быть даже невидимы для других транзакций.
***Долговечность (системы баз данных)***
Надежность гарантирует, что после того, как транзакция была зафиксирована, она останется зафиксированной даже в случае сбоя системы (например, отключения питания или сбоя). Обычно это означает, что завершенные транзакции (или их последствия) записываются в энергонезависимую память.
Именно статус ACID отличает элитные сервера баз данных особенно в режиме нескольких сотен , а иногда и нескольких тысяч транзакции в секунду . Например, Multi-master everywhere replications  (Informix Enterprise Replication) при добавлении нового Мастера возникает явление на сленге называемое OLTP удар. Я, например, не видел ничего эффективней Sun/Solaris (KAIO)

## 4.Виды первичных ключей?

Простые и составные ключи
Если первичный ключ состоит из единственного атрибута, его называют простым ключом. Если первичный ключ состоит из двух и более атрибутов, его называют составным ключом.

Ключ — это колонка (column) или колонки, не имеющие в строках дублирующих значений. Кроме того, колонки должны быть неприводимо уникальными, то есть никакое подмножество колонок не обладает такой уникальностью.


## 5.Что такое JDBC? Какие классы относятся к нему?

JDBC API - стандартный прикладной интерфейс Java, обесепчивающий взаимодействие приложения с СУБД. Это платформенно- независимый стандарт взаимодействия с реляционными БД, реализованный в Java в пакете java.sql(JDBC API). Является самым низкоуровневым API взаимодействия с СУБД, обладающим низким уровнем автоматизации и абстракции.
Здесь мы сами делаем запросы и сами переводим объекты Java в строки таблицы. JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

В JDBC есть 3 основных интерфейса:
- Connection – отвечает за соединение с базой данных. Интерфейс Connection представляет сессию соединения с базой данных, обеспечиваемую драйвером. Он также обеспечивает методы для создания выражений, управления соединениями и их свойствами.
- Statement – отвечает за запрос к базе данных
- ResultSet – отвечает за результат запроса к базе данных
  
Существует два интерфейса подключения к БД:
- Через DriverManager
- Через DataSource
  
- java.sql.DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.
- javax.sql.DataSource - решает те же задачи, что и DriverManager, но более удобным и универсальным образом. Существуют также javax.sql.ConnectionPoolDataSource и javax.sq1.XADataSource задача которых - обеспечение поддержки пула соединений.
- java.sql.Connection - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также предусмотрены интерфейсы javax.sql.PooledConnection и javax.sql.XAConnection.
- java.sql.Statement , java.sql.PreparedStatement и java.sql.CallableStatement - эти интерфейсы позволяют отправить запрос к источнику данных.
- java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения отдельных полей в текущей записи.
- java.sql.ResultSetMetaData - позволяет получить информацию о структуре набора данных.
- java.sql.DatabaseMetaData - позволяет получить информацию о структуре источника данных.
  

## 6.Что такое Statement, PreparedStatement?  В чем их отличие?

Statement - (объект для оператора JDBC) используется для отправки SQL-оператора на сервер баз данных. Объект для оператора связан с объектом Connection и является объектом, обрабатывающим взаимодействие между приложением и сервером баз(объект для оператора JDBC).

- Statement – SQL-выражение, подготовленное к выполнению в рамках определенной JDBC-сессии. Выполняется методом execute для обычного выражения, executeUpdate для модифицирующего, executeBatch для пакетного. Когда ожидаемый размер результата больше Integer.MAX_VALUE, используются версии методов executeLarge*.

После выполнения, экземпляр Statement владеет ResultSet-ом, и другими данными о результате выполнения, такими как количество обновленных записей и сгенерированные ключи.

- PreparedStatement – предскомпилированная версия Statement, его наследник. Эффективнее выполняет одно и то же выражение множество раз. Входные параметры объявляются в SQL-выражении символом ?, следом сеттерами задаются их типы и значения. Делегирует обязанность экранировать введенные пользователем параметры базе данных.

- CallableStatement – наследник PreparedStatement для вызова хранимых процедур. Кроме входных параметров, позволяет регистрировать выходные.

Экземпляры всех трех типов создаются методами интерфейса Connection.

1) Statement — используется для выполнения обычных запросов SQL. Вы не можете передавать параметры SQL-запросу во время выполнения с помощью этого интерфейса. Этот интерфейс предпочтительнее двух других интерфейсов, если вы выполняете конкретный SQL-запрос только один раз.
2) PreparedStatement — используется для выполнения динамических или параметризованных запросов SQL. Вы можете передать параметры SQL-запросу во время выполнения, используя этот интерфейс. Рекомендуется использовать PreparedStatement, если вы выполняете конкретный SQL-запрос несколько раз.
3) CallableStatement — используется для выполнения хранимых процедур. Процедура хранения — это группа операторов SQL, которая инкапсулирует все запросы и компилируется.
Хранимая процедура похожа на функцию или метод в классе, за исключением того, что она находится в базе данных.

Некоторые из преимуществ PreparedStatement по сравнению с Statement:
1. PreparedStatement помогает нам предотвратить атаки с использованием SQL-инъекций, поскольку он автоматически экранирует специальные символы.
2. PreparedStatement позволяет нам выполнять динамические запросы с вводом параметров.
3. PreparedStatement предоставляет различные типы методов установки для установки входных параметров запроса.
4. PreparedStatement быстрее, чем Statement. Это становится более заметным, когда мы повторно используем PreparedStatement или используем его методы пакетной обработки для выполнения нескольких запросов.
5. PreparedStatement помогает нам писать объектно-ориентированный код с помощью методов установки, тогда как с Statement мы должны использовать конкатенацию строк для создания запроса. Если необходимо установить несколько параметров, написание запроса с использованием конкатенации строк выглядит очень некрасиво и подвержено ошибкам. 
   
   - .executeUpdate() - метод, вызываемый на объекте statement'a, позволяющий обновить таблицу, к которой мы обращаемся. Выполняет такие команды, как INSERT, UPDATE, DELETE, CREATE TABLE, DROP TABLE. 
   - .executeQuery(SQL-запрос) - метод statement'a, выполняющий запрос к нашей базе данных и возвращает объект типа ResultSet, который инкапсулирует результат SQL - запроса. 

После этого нам надо вручную поместить данные, полученные в ResultSet'e, в наш Java объект путем итерации ResultSet'a через цикл while, последовательно заполняя поля объекта с помощью сеттеров значениями, полученными из колонок.

## 7.В чем отличие классов-наследников и вложенных/внутренних классов?
Класс, задаваемый внутри другого класса, принято называть внутренним. Существует четыре различных типа внутренних классов: класс верхнего уровня, член класса, локальный и анонимный классы.

Определение классов верхнего уровня почти ничем не отличается от определения обычных, внешних классов. Единственное различие состоит в том, что объявление данного класса находится в объявлении другого, поэтому перед ключевым словом class необходимо поставить ключевое слово static:
```
class OuterClass {
  static class InnerClass {
  }
}
```
Во время компиляции класса X генерируется два файла .class, один – для InnerClass и другой – для OuterClass.

## 8.Параметры для автоматической генерации БД на основе сущностей, hbm2ddl.auto?

Первая такая настройка — это параметр hbm2ddl.auto. У нее может быть 5 различных значений:

***validate***	Валидация: Hibernate проверит, совпадают ли имена и типа колонок и полей в базе и в аннотациях. Это самый частый режим.
***update***	Апдейт: Hibernate обновит таблицы в базе, если они или их колонки отличаются от ожидаемых.
***create***	Пересоздание: Hibernate удалит все таблицы в базе и создаст их заново на основе данных из аннотаций.
***create-drop***	Создание-удаление. В начале работы Hibernate создаст все таблицы, в конце работы – удалит их за собой.
***none***	Hibernate вообще ничего не будет делать. Если где-то база не совпадает с ожиданием, то будут сыпаться ошибки во время выполнения запросов.