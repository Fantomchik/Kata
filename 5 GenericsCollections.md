- [1. Что такое generic и для чего они нужны?](#1-что-такое-generic-и-для-чего-они-нужны)
- [2. Зачем вообще ввели дженерики? Как до дженериков программировали?](#2-зачем-вообще-ввели-дженерики-как-до-дженериков-программировали)
- [3. Что можно параметризовать?](#3-что-можно-параметризовать)
- [4. Статический метод типизирузется так же как и обычный - перед типом возвращаемого значения указывается параметр в угловых скобках .](#4-статический-метод-типизирузется-так-же-как-и-обычный---перед-типом-возвращаемого-значения-указывается-параметр-в-угловых-скобках-)
- [5. Что такое raw type? К чему приводит использование raw type?](#5-что-такое-raw-type-к-чему-приводит-использование-raw-type)
- [6. Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#6-если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
- [7. Что такое даймонд оператор?](#7-что-такое-даймонд-оператор)
- [8. Что такое wildcard?](#8-что-такое-wildcard)
- [9. Расскажи про иерархию коллекций?](#9-расскажи-про-иерархию-коллекций)
- [10. Расскажи отличие List от Set?](#10-расскажи-отличие-list-от-set)
- [11. Расскажи отличие ArrayList от LinkedList?](#11-расскажи-отличие-arraylist-от-linkedlist)
- [12. Когда лучше использовать ArrayList, а когда LinkedList?](#12-когда-лучше-использовать-arraylist-а-когда-linkedlist)
- [13. В чём разница между Queue и Deque и Stack?](#13-в-чём-разница-между-queue-и-deque-и-stack)
- [14. Отличие двусвязного и односвязного списка?](#14-отличие-двусвязного-и-односвязного-списка)
- [15. Как работает HashSet?](#15-как-работает-hashset)
- [16. Как работает метод contains в ArrayList, LinkedList, HashSet?](#16-как-работает-метод-contains-в-arraylist-linkedlist-hashset)
- [17. В чём разница между Iterable и Iterator?](#17-в-чём-разница-между-iterable-и-iterator)
- [18. Что такое Iterator?](#18-что-такое-iterator)
- [19. В каких случаях нужно использовать iterator? И почему?](#19-в-каких-случаях-нужно-использовать-iterator-и-почему)
- [20. Что такое Map? Что должно быть уникальным?](#20-что-такое-map-что-должно-быть-уникальным)
- [21. Может ли null быть ключём в HashMap?](#21-может-ли-null-быть-ключём-в-hashmap)
- [22. Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?](#22-как-работает-hashmap-расскажите-подробно-как-работает-метод-put-что-происходит-при-коллизии)
- [23. Как работает метод get в HashMap?](#23-как-работает-метод-get-в-hashmap)
## 1. Что такое generic и для чего они нужны?
`generic` (обобщения) представляют собой механизм, позволяющий создавать классы, интерфейсы и методы, которые могут работать с различными типами данных.

## 2. Зачем вообще ввели дженерики? Как до дженериков программировали?
Введение дженериков позволило разработчикам создавать универсальные и переиспользуемые компоненты, которые могут работать с различными типами данных. Обобщения обеспечивают безопасность типов данных во время компиляции, позволяют избежать приведения типов данных и упрощают код, делая его более читабельным и поддерживаемым. 

До введения дженериков разработчики должны были создавать отдельные классы или методы для каждого типа данных, с которыми они хотели работать. 
 
Это приводило к дублированию кода и увеличению сложности поддержки и разработки программы. Кроме того, без обобщений не было возможности обеспечить безопасность типов данных во время компиляции, что могло приводить к ошибкам типизации во время выполнения программы.

1. Повышение безопасности типов данных: Обобщения позволяют обеспечить безопасность типов данных во время компиляции. Это означает, что компилятор проверяет правильность типов данных на этапе компиляции, что помогает предотвратить ошибки типизации во время выполнения программы. 
 
2. Повышение переиспользуемости кода: Обобщения позволяют создавать универсальные компоненты, которые могут работать с различными типами данных. Это устраняет необходимость в дублировании кода для каждого типа данных и упрощает поддержку и разработку программы. 
 
3. Улучшение читаемости и поддерживаемости кода: Обобщенный код обычно более читаем и понятен, так как он выражает общую логику и алгоритмы, независимо от конкретных типов данных. Это делает код более легким для понимания и поддержки. 
 
4. Избегание приведения типов данных: Обобщения позволяют избежать необходимости вручную приводить типы данных, так как компилятор автоматически следит за правильностью типов. Это упрощает код и уменьшает вероятность ошибок. 
 
5. Улучшение производительности: Использование обобщений может привести к улучшению производительности программы, так как избегается необходимость в приведении типов данных во время выполнения. Это может привести к более эффективному выполнению кода. 
   
## 3. Что можно параметризовать?
Параметризовать можно классы, конструкторы, методы, интерфейсы, поля.

## 4. Статический метод типизирузется так же как и обычный - перед типом возвращаемого значения указывается параметр в угловых скобках <T>.

`public static <E> List<E> staticMethod(List <E> element) {}` статические переменные нельзя использовать с обобщенным типом класса, как и методы

Мы не можем создавать статические переменные с параметром типа, поскольку в момент компиляции тип этой переменной еще не будет известен

Так же с статическими методами, у них доступа к типу обобщения нет, так как в момент компиляции получается так же тип не известен, статические методы отдельно параметризуем

## 5. Что такое raw type? К чему приводит использование raw type?
Как известно, raw type(сырой тип) – это такие generic-типы, которые используются без задания типа-параметра. Данная конструкция допустима, но часто приводит к появлению warning от компилятора. Это связано с риском возникновения ситуации, которая называется heap pollution, это когда переменная, относящаяся к параметризованному типу, начинает ссылаться на не параметризированный объект. 
Heap pollution – ситуация, переменная параметризованного типа хранит в себе объект, параметризованный другим типом. Простейший пример:
`List<String> strings = (List) new ArrayList<Integer>();`

Применение raw type, в общем случае, недопустимо. Их поддержка в Java существует исключительно для поддержания совместимости с ранними версиями. 

Пример сырого типа `List list = new ArrayList();`
Пример нормального типа  `List <String> list = new ArrayList<>();`

## 6. Если поле типизировано дженериком как в байт коде будет представлен этот тип?
В байт-коде Java обобщенные типы стираются и заменяются на тип Object.
Например, если у вас есть обобщенный класс  `MyClass<T>` , то в байт-коде он будет представлен как  `MyClass<Object>` . Компилятор добавит необходимые приведения типов, чтобы обеспечить совместимость с кодом, который использует этот класс без параметризации. 

## 7. Что такое даймонд оператор?
Даймонд-оператор (diamond operator) в программировании Java обозначается символом "<>". Он используется для указания обобщенного типа данных при создании экземпляра обобщенного класса. 
 
Вместо явного указания типа данных в угловых скобках, даймонд-оператор позволяет компилятору вывести тип данных автоматически на основе контекста. Это делает код более компактным и улучшает его читаемость.

## 8. Что такое wildcard?
Wildcard — (сильная карта или символом подстановки) это дженерик, обозначается вопросительным знаком в угловых скобках <?>, означает, что тип может быть чем угодно.

Wildcard может использоваться при создании коллекций `List<?> exp = new ArrayList<String>();` 
В параметрах и типе возвращаемого значения метода `List<?> expMethod(List <?> e);`

Wldcard позволяет подставить любой тип вместо символа <?>
На первый взгляд кажется, что принцип PECS достаточно прост. Все, кто встречался с ним, знают, что это акроним, означающий «Producer Extends Consumer Super». Как объясняется в многочисленных статьях, если у нас есть некая коллекция, типизированная wildcard с верхней границей (extends) – то это, «продюсер». «Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает». Если же у нас коллекция, типизированная wildcard по нижней границе (super) – то это, «потребитель», который «только принимает, а предоставить ничего не может».

Для ограничения используется <? extends T> и <? super T>.
`<? extends T>` - означает что можно использовать всех наследников от типа Т и сам тип Т включительно.

`<? super T>` - означает что можно использовать только предков типа Т и сам тип Т включительно.

`<? extends Number>` - означает что можно использовать Integer, Long, Double и все что наследуется от Number.

Допустим есть класс Car и его наследник Car1 и наследник от Car1 класс Car2.
`<? super Car1>` - означает что можно использовать сам класс Car1 и класс Car. Т.е. можно использовать только предков.

-- Upper Bounded Wildcards, Lower Bounded Wildcards?
Аналогично PECS. Upper Bounded Wildcards - extends T.
Lower Bounded Wildcards - super T.

## 9. Расскажи про иерархию коллекций?
На вершине иерархии в Java Collections Framework располагаются 2 интерфейса: Collection и Map.
Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).

## 10. Расскажи отличие List от Set?
Список - упорядоченная последовательность элементов, тогда как Set - это отдельный список элементов, которые неупорядочены

Список - это тип упорядоченной коллекции, которая поддерживает элементы в порядке вставки, в то время как Set - это тип неупорядоченной коллекции, поэтому элементы не поддерживаются в каком-либо порядке.

Список позволяет дублировать, а Set не позволяет дублировать элементы. Все элементы набора должны быть уникальными, если вы попытаетесь вставить дублирующий элемент в Set, это заменит существующее значение.

Список разрешает любое количество нулевых значений в своей коллекции, в то время как Set разрешает только одно значение null в его коллекции.

Новые методы определены внутри интерфейса List. Но в интерфейсе Set нет новых методов, поэтому мы должны использовать методы интерфейса Collection только с помощью подклассов Set.

Список можно вставлять как в прямом направлении, так и в обратном направлении с помощью Listiterator, в то время как Set можно перемещать только в прямом направлении с помощью итератора

## 11. Расскажи отличие ArrayList от LinkedList?
ArrayList реализован внутри в виде обычного массива, доступ по индексу и вставка в конец происходит очень быстро. Для вставки в середину или начало приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. LinkedList реализован в виде двухсвязного списка. Каждый элемент знает предыдущий и следующий за ним. Вставка осуществляется быстро за счет простого изменения ссылок на соседние элементы. А обход по всем элементам занимает много времени.
Исходя из вышеописанного, процедура выборки произвольного элемента по индексу будет быстро отрабатываться для ArrayList и намного медленней для LinkedList. Причем время выборки для ArrayList незначительно зависит от количества элементов в массиве, а для LinkedList оно растет пропорционально.Исходя из вышеописанного, процедура выборки произвольного элемента по индексу будет быстро отрабатываться для ArrayList и намного медленней для LinkedList. Причем время выборки для ArrayList незначительно зависит от количества элементов в массиве, а для LinkedList оно растет пропорционально.

## 12. Когда лучше использовать ArrayList, а когда LinkedList?
Часто указывается что там где нужно добавлять и удалять много элементов из середины нужно использовать LinkedList. А там где нужен доступ по индексу и добавление в конец - ArrayList. Но по факту лучше стараться почти всегда использовать ArrayList. Т.к в большинстве случаев LinkedList проигрывает по потребляемой памяти и по скорости выполнения операций ArrayList. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.

## 13. В чём разница между Queue и Deque и Stack?
Queue - Очередь. Этот список, который используется для реализации концепции FIFO (first in, first out) — «первым пришёл — первым ушёл».
В Queue элементы обычно добавляются в конец.

Deque (двусторонняя очередь) в Java представляет собой интерфейс, который расширяет интерфейс Queue и представляет собой коллекцию, в которой элементы могут быть добавлены или удалены как в начале, так и в конце очереди. Он предоставляет методы для добавления, удаления и доступа к элементам с обоих концов очереди. 

Stack — представляет собой интерфейс. это линейная структура данных, которая следует принципу LIFO (последний пришел, первый ушел). Это означает, что объекты могут быть вставлены или удалены только с одного конца, также называемого вершиной.

## 14. Отличие двусвязного и односвязного списка?
"Связной" список, или другими словами односвязный - список, где каждый элемент ссылается только на один следующий. У последнего нет ссылки.

"Двусвязной" или двусвязный - список, где каждый элемент ссылается на следующий и предыдущий. Первый и последний соответственно не имеют ссылок на предыдущий и следующий.

## 15. Как работает HashSet?
Хеш сет представляет собой таблицу хеш кодов, которая генерируется при добавлении элемента. Элементами хеш сета могут быть только уникальные значения ключа, и одно null значение.

HashSet основан на HashMap, и так же представляет собой массив. HashSet использует хеш таблицы. В начале вычисляется хеш код объекта. На основании хеша и размера массива вычисляется индекс массива. По этому индексу кладется объект. Если происходит коллизия ( эта ячейка не пустая), то в эту же ячейку ложится новый объект и используется односвязный список между ними.

Что в HashSet используется вместо значений HashMap?
new Object. (константа PRESENT - заглушка)

Почему в HashSet используется new Object а не null для value значений?
В HashSet используется new Object в качестве значения внутреннего экземпляра HashMap, а не null, потому что в HashMap ключи хранятся в виде пар ключ-значение, и каждый ключ должен быть связан с каким-то значением. В данном случае, значение не имеет значения и используется только сам ключ. 
 
Использование new Object вместо null обеспечивает компактность и оптимизацию памяти. Если бы значения были установлены в null, то для каждого ключа в HashMap было бы необходимо выделить дополнительное место для хранения null-значений, что привело бы к дополнительным расходам памяти. 

## 16. Как работает метод contains в ArrayList, LinkedList, HashSet?
   - ArrayList: 
   В ArrayList метод  contains()  выполняет линейный поиск элемента, сравнивая его с каждым элементом в списке. Он использует метод  equals()  для сравнения элементов. Если элемент найден, метод  contains()  возвращает значение  true , в противном случае -  false . 
   - LinkedList: 
   В LinkedList метод  contains()  также выполняет линейный поиск элемента, начиная с первого элемента и переходя к следующему элементу с помощью ссылок на следующий элемент. Он также использует метод  equals()  для сравнения элементов. Если элемент найден, метод  contains()  возвращает значение  true , в противном случае -  false . 
   - HashSet: 
   В HashSet метод  contains()  использует хэш-код элемента для определения его наличия в коллекции. Сначала он вычисляет хэш-код искомого элемента, а затем проверяет, есть ли элемент с таким же хэш-кодом в коллекции. Если элемент с таким хэш-кодом найден, метод  contains()  дополнительно использует метод  equals()  для сравнения элементов. Если элемент найден, метод  contains()  возвращает значение  true , в противном случае -  false . 
 
Во всех трех классах  contains()  выполняется за время O(n), где n - количество элементов в коллекции. Однако в HashSet поиск элемента может быть более эффективным благодаря использованию хэш-кодов и структуре хэш-таблицы.


## 17. В чём разница между Iterable и Iterator?
Iterable - это простое представление серии элементов, которые могут быть итерированы поверх. У него нет никакого состояния итерации такого как "текущий элемент". Вместо этого у него есть один метод, который производит Iterator.
Iterator - это объект с состоянием итерации. Он позволяет проверить, есть ли у него больше элементов с помощью hasNext() и переместиться на следующий элемент (если есть) с помощью next(). И метод Remove.
1. Iterable: 
   - Интерфейс, который предоставляет возможность перебирать элементы в коллекции. 
   - Он определяет метод  iterator() , который возвращает объект типа Iterator для перебора элементов. 
   - Iterable позволяет использовать цикл for-each для перебора элементов коллекции без явного использования итератора. 
   - Он не содержит методов для доступа к элементам или изменения коллекции, он только предоставляет возможность перебора элементов. 
 
2. Iterator: 
   - Интерфейс, который предоставляет методы для последовательного доступа и удаления элементов в коллекции. 
   - Он определяет методы  hasNext() ,  next()  и  remove() . 
   - Iterator позволяет получить доступ к элементам коллекции по одному итеративно и удалить элементы из коллекции во время итерации. 
   - Он предоставляет более низкоуровневый доступ к элементам и больше гибкости по сравнению с Iterable. 


## 18. Что такое Iterator?
Дословно «Iterator» можно перевести как «переборщик». То есть это некая сущность, способная перебрать все элементы в коллекции. При этом она позволяет это сделать без вникания во внутреннюю структуру и устройство коллекций.

## 19. В каких случаях нужно использовать iterator? И почему?
1. Обход коллекции: Итератор предоставляет удобный способ последовательного доступа и обхода элементов в коллекции. Он позволяет перебирать элементы коллекции один за другим без необходимости знать внутреннюю структуру коллекции. Итератор предоставляет методы  hasNext()  и  next() , которые позволяют проверять наличие следующего элемента и получать его соответственно. 
 
2. Удаление элементов: Итератор позволяет безопасно удалять элементы из коллекции во время итерации. Метод  remove()  удаляет текущий элемент из коллекции, и этот метод может быть вызван только после вызова  next() . Это позволяет удалить элемент, не нарушая целостность коллекции и избегая ошибок. 
 
3. Параллельный доступ: Итераторы обеспечивают безопасный параллельный доступ к коллекции. Если несколько потоков пытаются изменить коллекцию одновременно, использование итератора позволяет избежать ошибок, таких как ConcurrentModificationException. 
 
4. Универсальность: Итератор является универсальным механизмом для обхода элементов в различных типах коллекций. Он может использоваться с различными классами коллекций, такими как ArrayList, LinkedList, HashSet и другими, без необходимости знать конкретную реализацию.

Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?
Итератор похож на указатель своими основными операциями: он указывает на отдельный элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции для перехода к другому элементу списка (следующему или предыдущему). Контейнер, который реализует поддержку итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны ли все элементы контейнера (является ли итератор конечным). Таким образом без курсора просто нельзя будет реализовать безошибочное передвижение по коллекции.

Зачем в итераторе метод remove?
Метод remove() в итераторе используется для удаления элемента из коллекции, на которую ссылается итератор. Он предоставляет возможность безопасно удалять элементы во время итерации, чтобы избежать ошибок и несогласованности. 

Преимущество использования метода remove() состоит в том, что он обеспечивает правильное обновление внутреннего состояния итератора и коллекции. Если бы мы позволили удалить элемент напрямую из коллекции, не используя метод remove() итератора, это могло бы привести к ошибкам или несогласованности в итерации. 
 
Кроме того, метод remove() также обрабатывает ситуацию, когда элемент был удален из коллекции другим способом, не через итератор. В этом случае метод remove() вызывает исключение ConcurrentModificationException, чтобы указать на то, что коллекция была изменена неправильным образом. 

## 20. Что такое Map? Что должно быть уникальным?
Map (отображение) в Java представляет собой интерфейс, который предоставляет структуру данных для хранения пар "ключ-значение". Каждый элемент в Map состоит из уникального ключа и соответствующего ему значения. Ключи используются для доступа к значениям в Map. 
 
Что должно быть уникальным в Map, это ключи. Каждый ключ в Map должен быть уникальным, то есть в Map не может быть двух элементов с одинаковыми ключами. Если вставляется элемент с уже существующим ключом, то он заменяет предыдущее значение, связанное с этим ключом. 

***Основные коллекции интерфейса Map?***
HashMap, LinkedHashMap, TreeMap, Hashtable.

***Почему Map не наследуется от Collection?***
Map в Java не наследуется от интерфейса Collection, потому что они предоставляют разные способы организации и хранения данных. 
 
Интерфейс Collection предназначен для хранения и манипулирования группами объектов, где каждый объект может быть доступен по отдельному индексу или итерироваться по элементам коллекции. Он предоставляет методы для добавления, удаления, поиска и манипулирования элементами в коллекции. 
 
С другой стороны, интерфейс Map представляет собой ассоциативный массив, где каждый элемент представляет собой пару "ключ-значение". Он обеспечивает быстрый доступ к значениям по ключу, а не по индексу, и предоставляет методы для добавления, удаления и поиска элементов по ключу. 


## 21. Может ли null быть ключём в HashMap?
HashMap позволяет хранить одно null значение ключа и несколько null значений.

## 22. Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?
HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка элементов с течением времени. 

Метод put() в HashMap используется для добавления элемента в коллекцию. Вот подробное описание того, как он работает: 
   1. Сначала метод put() получает хэш-код ключа, который будет использоваться для определения индекса внутри хэш-таблицы. Хэш-код - это целое число, которое вычисляется на основе содержимого ключа. 
   2. Затем метод put() вычисляет индекс в хэш-таблице, используя хэш-код ключа и размер хэш-таблицы. Обычно индекс вычисляется путем взятия остатка от деления хэш-кода на размер таблицы. 
   3. Если в этом индексе нет элементов, то новый элемент добавляется на этот индекс в хэш-таблице. 
   4. Если в этом индексе уже есть элементы, то происходит проверка на равенство ключей. Если ключ нового элемента совпадает с ключом уже существующего элемента, то значение этого элемента обновляется новым значением. 
   5. Если ключи не совпадают, то происходит коллизия. Коллизия возникает, когда два или более ключей имеют одинаковый индекс в хэш-таблице. В этом случае элементы с одинаковыми индексами хранятся в связанных списках, называемых "цепочками коллизий". (что происходит при коллизии?)
   6. В цепочке коллизий происходит последовательный поиск элемента с совпадающим ключом. Если такой элемент найден, то его значение обновляется новым значением. 
   7. Если элемент с совпадающим ключом не найден, то новый элемент добавляется в начало цепочки коллизий. 
   8. Если количество элементов в HashMap превышает заданный порог, происходит операция "рехэширования". Рехэширование включает увеличение размера таблицы и перераспределение элементов для уменьшения коллизий и поддержания эффективности. 


## 23. Как работает метод get в HashMap?

Метод get() в HashMap используется для получения значения, связанного с определенным ключом в коллекции. Вот подробное описание того, как он работает: 
 1. Сначала метод get() получает хэш-код ключа, который будет использоваться для определения индекса внутри хэш-таблицы. Хэш-код - это целое число, которое вычисляется на основе содержимого ключа. 
 2. Затем метод get() вычисляет индекс в хэш-таблице, используя хэш-код ключа и размер хэш-таблицы. Обычно индекс вычисляется путем взятия остатка от деления хэш-кода на размер таблицы.  
 3. Если в этом индексе нет элементов, то метод get() возвращает значение null, указывая на то, что элемент с таким ключом не найден. 
 4. Если в этом индексе есть элементы, происходит поиск элемента с совпадающим ключом. Если элемент с таким ключом найден, то метод get() возвращает его значение. 
 5. Если в этом индексе есть несколько элементов, которые хранятся в цепочке коллизий, метод get() последовательно просматривает элементы в цепочке и сравнивает ключи. Если элемент с совпадающим ключом найден, то метод get() возвращает его значение. 

***Чем отличается метод Put и Get для HashMap?***
Put вставляет новый элемент в ноду или перезаписывает имеющийся. Метод Get позволяет получить имеющуюся пару, тем же образом что и запись, только без добавления.

***Как решается коллизия HashMap?***
При совпадении хеш кода, объект сравнивается на равенство ссылок а затем по equals. Если Совпадение найдено то значение у ключа перезаписывается. Если не найдено, то создается новая нода и прикрепляется к структуре существующих нод бакета.

***Что такое HashtTable, чем она отличается от HashMap?***
HashtTable- deprecated. Не рекомендована к использованию. Как и HashMap, в Java Hashtable хранит пары ключей/значений в хэш-таблице. Основные отличия HashtTable - синхронизирована и медленнее работает и не позволяет иметь null ключей и значений.

***Что такое красно-черное дерево?***

Красно-чёрное дерево (англ. red-black tree, RB tree) — один из видов самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла.

Структура для хранения данных. Если в кратце, то у любого дерева есть корень. Если нужное значение меньше чем корень, то поиск идет в левой части, если больше то в правой.

Каждый узел промаркирован красным или чёрным цветом
Корень и конечные узлы (листья) дерева — чёрные
У красного узла родительский узел — чёрный
Все простые пути из любого узла x до листьев содержат одинаковое количество чёрных узлов
Чёрный узел может иметь чёрного родителя


***Условия перестроения в красно-черное дерево (одеревенение) HashMap?/При каких условиях в HashMap LinkedList преобразуется в красно-черное дерево?***

если в хеш-таблице по крайней мере 64 бакета и в одном бакете 8 или более элементов, то произойдет переход к древовидной структуре.

В случае, когда структурой была цепочка а не дерево, и длина цепочки превысила 7 элементов - происходит процедура treeification - превращение списка в самобалансирующееся дерево. В случае коллизии это ускоряет доступ к элементам на чтение с O(n) до O(log(n)). У comparable-ключей для балансировки используется их естественный порядок. Другие ключи балансируются по порядку имен их классов и значениям identityHashCode-ов. Для маленьких хэш-таблиц (< 64 бакетов) «одеревенение» заменяется увеличением (см. п.8).

***Какие реализации SortedSet вы знаете и в чем их особенность?***

TreeSet - реализует SortedSet. Реализации этого интерфейса, следит за уникальностью хранимых объектов и поддерживают их в порядке возрастания. Отношение порядка между объектами может быть определено, помощью метода compareTo интерфейса Comparable<T>, или при помощи специального класса-компаратора, наследующего интерфейс Comparator<T>.

***Порядок следования в коллекциях?***

HashMap/HashSet - "случайный" порядок(удобный для Map/Set) хранения элементов. ТгееМар/ТгееSet - хранит эл-ты в порядке возрастания элементов. LinkedHashMap/LinkedHashSet - хранит эл-ты в порядке добавления элементов.

***Что такое ковариантность и контравариантность?***

Ковариантность – следование существующей иерархии (последовательности) наследования. Например, если класс Dog наследник Animal, то IEnumerble <Dog> будет потомком IEnumerble <Animal>. Перечисление собак – отдельный случай перечисления всех животных.

Контравариантность – это изменение порядка наследования на противоположную. Рассмотрим следующий вариант. String является наследником Object. Делегат Action<T> это метод, который принимает объекты типа Т. Тогда Action<Object> – наследник Action<String>. Ведь если строки являются объектами, то метод способный производить операции над любыми объектами, способна выполнять их и над строкой.

***Что такое Инвариантность ?***

Инвариантность - это отсутствие свойств ковариантности и контрвариантности. Дженерики без вайлдкардов инвариантны: List<Number> нельзя положить ни в переменную типа List<Double>, ни в List<Object>. Массивы ковариантны: в переменную Object[] можно присвоить значение типа String[].

Инвариантность — ситуация, когда наследование исходных типов не переносится на производные. В List<Number> нельзя присвоить ничего кроме List<Number> не List<Integer> не List<Double>. Отношение предок-родитель не работает. Это сделано для типобезопасности.


***В чем разница между интерфейсами Comparable и Comparator?***

Коротко:
Comparable используется для естественной сортировки(по возрастанию).
Comparator для сортировки по разным шаблонам.

Подробно:
Классы-обертки как Integer, Double и String реализуют интерфейс Comparable. По этому метод sort ,без параметров может сортировать эти объекты.
Интерфейс Comparable может быть реализован именно элементами коллекции или ключами Map.
Так же интерфейсом Comparable может пользоваться любой класс который его реализует и переопределяет.

Если у вас нет доступа к классу можно реализовать интерфейс Comparator.

Comparator реализуется отдельным объектом (это удобно, так как можно заготовить несколько реализаций для разных правил сортировок, не меняя при этом код элементов коллекции/ключей Map).

***Что возвращает Comparator и Comparable?***

- 0 если объекты равны.
- -1 (отрицательное число) если сравниваемый объект(1 объект) меньше передаваемого(2го объекта)
- 1 (положительное число) если сравниваемый объект(1 объект) больше передаваемого(2го объекта)

***Почему коллекции не наследуют интерфейсы Cloneable и Serializable?***

Ну, простейший ответ — «потому что не надо». Функционал предоставляемый интерфейсами Cloneable и Serializable просто не нужен для коллекций. (Тут стоит сделать исключение для ArrayList и LinkedList, которые их реализуют).

Еще одна причина — далеко не всегда нужен подкласс Cloneable потому что каждая операция клонирования потребляет очень много памяти, и неопытные программисты могут расходовать ее сами не понимая последствий.

И последняя причина — клонирование и сериализация являются очень узкоспецифичными операциями, и реализовывать их нужно только когда это необходимо. Многие классы коллекции реализуют данные интерфейсы, но совершенно незачем закладывать их для всех коллекций вообще. Если вам нужно клонирование и сериализация — просто воспользуйтесь теми классами где она есть, если нет — остальными классами.


***Какую функциональность представляет класс Collections?***

Collections.sort() - сортировка 
Collections.shuffle() - Перемешивает коллекцию в случайном порядке. Collections.reverse() - Переворачивает коллекцию в обратном порядке. Collections.binarySearch() - Поиск в коллекции по ключу с использованием бинарного поиска. 
Collections.copy() - Копирует коллекцию источник src в dest. 
Collections.frequency() - Возвращает число вхождений объекта в коллекции. Collections.synchronizedCollection() - Возвращает синхронизированную (потокобезопасную) коллекцию.

***Методы интерфейса Collection  ***

1. add(Object o) Добавление элемента в коллекцию, если он отсутствует. Возвращает true, если элемент добавлен.  
2. addAll(Collection c)  Добавление элементов коллекции, если они отсутствуют.  
3. clear()  Очистка коллекции.  
3. contains(Object o)  Проверка присутствия элемента в наборе. Возвращает true, если элемент найден.  
4. containsAll(Collection c)  Проверка присутствия коллекции в наборе. Возвращает true, если все элементы содержатся в наборе.  
5. equals(Object o) Проверка на равенство.  
6. hashCode()  Получение hashCode набора.  
7. isEmpty()  Проверка наличия элементов. Возвращает true если в коллекции нет ни одного элемента.  
8. iterator()  Функция получения итератора коллекции.  
9. remove(Object o)  Удаление элемента из набора.  
10. removeAll(Collection c)  Удаление из набора всех элементов переданной коллекции.  
11. retainAll(Collection c)  Удаление элементов, не принадлежащих переданной коллекции.  
12. size()  Количество элементов коллекции  
12. toArray()  Преобразование набора в массив элементов.  
13. toArray(T[] a)  Преобразование набора в массив элементов. В отличии от предыдущего метода, который возвращает массив объектов типа Object, данный метод возвращает массив объектов типа, переданного в параметре.

