- [1. Что такое generic и для чего они нужны?](#1-что-такое-generic-и-для-чего-они-нужны)
- [2. Зачем вообще ввели дженерики? Как до дженериков программировали?](#2-зачем-вообще-ввели-дженерики-как-до-дженериков-программировали)
- [3. Что можно параметризовать?](#3-что-можно-параметризовать)
- [4. Статический метод типизирузется так же как и обычный - перед типом возвращаемого значения указывается параметр в угловых скобках .](#4-статический-метод-типизирузется-так-же-как-и-обычный---перед-типом-возвращаемого-значения-указывается-параметр-в-угловых-скобках-)
- [5. Что такое raw type? К чему приводит использование raw type?](#5-что-такое-raw-type-к-чему-приводит-использование-raw-type)
- [6. Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#6-если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
- [7. Что такое даймонд оператор?](#7-что-такое-даймонд-оператор)
- [8. Что такое wildcard?](#8-что-такое-wildcard)
- [9. Расскажи про иерархию коллекций?](#9-расскажи-про-иерархию-коллекций)
- [10. Расскажи отличие List от Set?](#10-расскажи-отличие-list-от-set)
- [11. Расскажи отличие ArrayList от LinkedList?](#11-расскажи-отличие-arraylist-от-linkedlist)
- [12. Когда лучше использовать ArrayList, а когда LinkedList?](#12-когда-лучше-использовать-arraylist-а-когда-linkedlist)
- [13. В чём разница между Queue и Deque и Stack?](#13-в-чём-разница-между-queue-и-deque-и-stack)
- [14. Отличие двусвязного и односвязного списка?](#14-отличие-двусвязного-и-односвязного-списка)
- [15. Как работает HashSet?](#15-как-работает-hashset)
- [16. Как работает метод contains в ArrayList, LinkedList, HashSet?](#16-как-работает-метод-contains-в-arraylist-linkedlist-hashset)
- [17. В чём разница между Iterable и Iterator?](#17-в-чём-разница-между-iterable-и-iterator)
- [18. Что такое Iterator?](#18-что-такое-iterator)
- [19. В каких случаях нужно использовать iterator? И почему?](#19-в-каких-случаях-нужно-использовать-iterator-и-почему)
- [20. Что такое Map? Что должно быть уникальным?](#20-что-такое-map-что-должно-быть-уникальным)
- [21. Может ли null быть ключём в HashMap?](#21-может-ли-null-быть-ключём-в-hashmap)
- [22. Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?](#22-как-работает-hashmap-расскажите-подробно-как-работает-метод-put-что-происходит-при-коллизии)
- [23. Как работает метод get в HashMap?](#23-как-работает-метод-get-в-hashmap)
## 1. Что такое generic и для чего они нужны?
`generic` (обобщения) представляют собой механизм, позволяющий создавать классы, интерфейсы и методы, которые могут работать с различными типами данных.

## 2. Зачем вообще ввели дженерики? Как до дженериков программировали?
Введение дженериков позволило разработчикам создавать универсальные и переиспользуемые компоненты, которые могут работать с различными типами данных. Обобщения обеспечивают безопасность типов данных во время компиляции, позволяют избежать приведения типов данных и упрощают код, делая его более читабельным и поддерживаемым. 

До введения дженериков разработчики должны были создавать отдельные классы или методы для каждого типа данных, с которыми они хотели работать. 
 
Это приводило к дублированию кода и увеличению сложности поддержки и разработки программы. Кроме того, без обобщений не было возможности обеспечить безопасность типов данных во время компиляции, что могло приводить к ошибкам типизации во время выполнения программы.

1. Повышение безопасности типов данных: Обобщения позволяют обеспечить безопасность типов данных во время компиляции. Это означает, что компилятор проверяет правильность типов данных на этапе компиляции, что помогает предотвратить ошибки типизации во время выполнения программы. 
 
2. Повышение переиспользуемости кода: Обобщения позволяют создавать универсальные компоненты, которые могут работать с различными типами данных. Это устраняет необходимость в дублировании кода для каждого типа данных и упрощает поддержку и разработку программы. 
 
3. Улучшение читаемости и поддерживаемости кода: Обобщенный код обычно более читаем и понятен, так как он выражает общую логику и алгоритмы, независимо от конкретных типов данных. Это делает код более легким для понимания и поддержки. 
 
4. Избегание приведения типов данных: Обобщения позволяют избежать необходимости вручную приводить типы данных, так как компилятор автоматически следит за правильностью типов. Это упрощает код и уменьшает вероятность ошибок. 
 
5. Улучшение производительности: Использование обобщений может привести к улучшению производительности программы, так как избегается необходимость в приведении типов данных во время выполнения. Это может привести к более эффективному выполнению кода. 
   
## 3. Что можно параметризовать?
Параметризовать можно классы, конструкторы, методы, интерфейсы, поля.

## 4. Статический метод типизирузется так же как и обычный - перед типом возвращаемого значения указывается параметр в угловых скобках <T>.

`public static <E> List<E> staticMethod(List <E> element) {}` статические переменные нельзя использовать с обобщенным типом класса, как и методы

Мы не можем создавать статические переменные с параметром типа, поскольку в момент компиляции тип этой переменной еще не будет известен

Так же с статическими методами, у них доступа к типу обобщения нет, так как в момент компиляции получается так же тип не известен, статические методы отдельно параметризуем

## 5. Что такое raw type? К чему приводит использование raw type?
Как известно, raw type(сырой тип) – это такие generic-типы, которые используются без задания типа-параметра. Данная конструкция допустима, но часто приводит к появлению warning от компилятора. Это связано с риском возникновения ситуации, которая называется heap pollution, это когда переменная, относящаяся к параметризованному типу, начинает ссылаться на не параметризированный объект. 
Heap pollution – ситуация, переменная параметризованного типа хранит в себе объект, параметризованный другим типом. Простейший пример:
`List<String> strings = (List) new ArrayList<Integer>();`

Применение raw type, в общем случае, недопустимо. Их поддержка в Java существует исключительно для поддержания совместимости с ранними версиями. 

Пример сырого типа `List list = new ArrayList();`
Пример нормального типа  `List <String> list = new ArrayList<>();`

## 6. Если поле типизировано дженериком как в байт коде будет представлен этот тип?
В байт-коде Java обобщенные типы стираются и заменяются на тип Object.
Например, если у вас есть обобщенный класс  `MyClass<T>` , то в байт-коде он будет представлен как  `MyClass<Object>` . Компилятор добавит необходимые приведения типов, чтобы обеспечить совместимость с кодом, который использует этот класс без параметризации. 

## 7. Что такое даймонд оператор?
Даймонд-оператор (diamond operator) в программировании Java обозначается символом "<>". Он используется для указания обобщенного типа данных при создании экземпляра обобщенного класса. 
 
Вместо явного указания типа данных в угловых скобках, даймонд-оператор позволяет компилятору вывести тип данных автоматически на основе контекста. Это делает код более компактным и улучшает его читаемость.

## 8. Что такое wildcard?
Wildcard — (сильная карта или символом подстановки) это дженерик, обозначается вопросительным знаком в угловых скобках <?>, означает, что тип может быть чем угодно.

Wildcard может использоваться при создании коллекций `List<?> exp = new ArrayList<String>();` 
В параметрах и типе возвращаемого значения метода `List<?> expMethod(List <?> e);`

Wldcard позволяет подставить любой тип вместо символа <?>
На первый взгляд кажется, что принцип PECS достаточно прост. Все, кто встречался с ним, знают, что это акроним, означающий «Producer Extends Consumer Super». Как объясняется в многочисленных статьях, если у нас есть некая коллекция, типизированная wildcard с верхней границей (extends) – то это, «продюсер». «Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает». Если же у нас коллекция, типизированная wildcard по нижней границе (super) – то это, «потребитель», который «только принимает, а предоставить ничего не может».

Для ограничения используется <? extends T> и <? super T>.
`<? extends T>` - означает что можно использовать всех наследников от типа Т и сам тип Т включительно.

`<? super T>` - означает что можно использовать только предков типа Т и сам тип Т включительно.

`<? extends Number>` - означает что можно использовать Integer, Long, Double и все что наследуется от Number.

Допустим есть класс Car и его наследник Car1 и наследник от Car1 класс Car2.
`<? super Car1>` - означает что можно использовать сам класс Car1 и класс Car. Т.е. можно использовать только предков.

-- Upper Bounded Wildcards, Lower Bounded Wildcards?
Аналогично PECS. Upper Bounded Wildcards - extends T.
Lower Bounded Wildcards - super T.

## 9. Расскажи про иерархию коллекций?
На вершине иерархии в Java Collections Framework располагаются 2 интерфейса: Collection и Map.
Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).

## 10. Расскажи отличие List от Set?
Список - упорядоченная последовательность элементов, тогда как Set - это отдельный список элементов, которые неупорядочены

Список - это тип упорядоченной коллекции, которая поддерживает элементы в порядке вставки, в то время как Set - это тип неупорядоченной коллекции, поэтому элементы не поддерживаются в каком-либо порядке.

Список позволяет дублировать, а Set не позволяет дублировать элементы. Все элементы набора должны быть уникальными, если вы попытаетесь вставить дублирующий элемент в Set, это заменит существующее значение.

Список разрешает любое количество нулевых значений в своей коллекции, в то время как Set разрешает только одно значение null в его коллекции.

Новые методы определены внутри интерфейса List. Но в интерфейсе Set нет новых методов, поэтому мы должны использовать методы интерфейса Collection только с помощью подклассов Set.

Список можно вставлять как в прямом направлении, так и в обратном направлении с помощью Listiterator, в то время как Set можно перемещать только в прямом направлении с помощью итератора

## 11. Расскажи отличие ArrayList от LinkedList?
## 12. Когда лучше использовать ArrayList, а когда LinkedList?
## 13. В чём разница между Queue и Deque и Stack?
## 14. Отличие двусвязного и односвязного списка?
## 15. Как работает HashSet?
## 16. Как работает метод contains в ArrayList, LinkedList, HashSet?
## 17. В чём разница между Iterable и Iterator?
## 18. Что такое Iterator?
## 19. В каких случаях нужно использовать iterator? И почему?
## 20. Что такое Map? Что должно быть уникальным?
## 21. Может ли null быть ключём в HashMap?
## 22. Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?
## 23. Как работает метод get в HashMap?