- [1. Зачем нужно функциональное программирование, где оно применяется и в чем его отличие от программирования в стиле ооп или в процедурном стиле?](#1-зачем-нужно-функциональное-программирование-где-оно-применяется-и-в-чем-его-отличие-от-программирования-в-стиле-ооп-или-в-процедурном-стиле)
- [2. Что такое функциональный интерфейс?](#2-что-такое-функциональный-интерфейс)
- [3. Зачем нужна аннотация @FunctionalInterface? Обязательна ли она?](#3-зачем-нужна-аннотация-functionalinterface-обязательна-ли-она)
- [4. Что такое default методы в интерфейсе и для чего они были введены?](#4-что-такое-default-методы-в-интерфейсе-и-для-чего-они-были-введены)
- [5. Может ли функциональный интерфейс содержать что-то кроме абстрактного метода?](#5-может-ли-функциональный-интерфейс-содержать-что-то-кроме-абстрактного-метода)
- [6. Все способы реализации функционального интерфейса?](#6-все-способы-реализации-функционального-интерфейса)
- [7. Что такое метод референс?](#7-что-такое-метод-референс)
- [8. Что такое «анонимные классы»?](#8-что-такое-анонимные-классы)
- [9. Как создать экземпляр анонимного класса?](#9-как-создать-экземпляр-анонимного-класса)
- [10. Что такое лямбда-выражение? Как его записать?](#10-что-такое-лямбда-выражение-как-его-записать)
- [11. Расскажите про Comparator и Comparable?](#11-расскажите-про-comparator-и-comparable)
- [12. Что такое стримы? Для чего они нужны? Когда их лучше использовать?](#12-что-такое-стримы-для-чего-они-нужны-когда-их-лучше-использовать)
- [13. Какие есть виды стримов?](#13-какие-есть-виды-стримов)
- [14. Способы создания Стрима?](#14-способы-создания-стрима)
- [15. Что такое терминальная операция?](#15-что-такое-терминальная-операция)
- [16. Что возвращают промежуточные операции над стримом?](#16-что-возвращают-промежуточные-операции-над-стримом)
- [17. В чем разница map и flatMap?](#17-в-чем-разница-map-и-flatmap)
- [18. Что такое ленивая инициализация стрима?](#18-что-такое-ленивая-инициализация-стрима)
- [19. Можно ли вызвать 2 терминальные операции?](#19-можно-ли-вызвать-2-терминальные-операции)
- [20. Что будет, если терминальной операции не будет?](#20-что-будет-если-терминальной-операции-не-будет)
- [21. Может ли стрим использоваться повторно?](#21-может-ли-стрим-использоваться-повторно)
- [22. Для чего нужны параллельные стримы?](#22-для-чего-нужны-параллельные-стримы)
- [23. В чём разница между forEach и peek?](#23-в-чём-разница-между-foreach-и-peek)

## 1. Зачем нужно функциональное программирование, где оно применяется и в чем его отличие от программирования в стиле ооп или в процедурном стиле?

Функциональное программирование - это стиль программирования, в котором программа разбивается на функции, которые не имеют состояния и не изменяют данные. Оно основано на математическом понятии функции и лямбда-исчислении. 

Например, y = x * x (выражение). Это функция возведения в квадрат переменной x, результатом станет переменная y. И во всем функциональном программировании так - вы пишете кучу функций, которые преобразуют одно в другое и передают дальше. У программы нет общего состояния, которое существует при императивном подходе. Поэтому не имеет значения, в какой последовательности вызывать функции. Их даже можно вызывать параллельно. Узнаёте декларативный подход? Вы пишете, что нужно делать, а не как.

Где применяется?
Обычно функциональное программирование имеет смысл применять тогда, когда программные решения легко выражаются при помощи функций и не имеют тесной связи с реальным миром. 

В чем отличие от ооп и проц стилей?
В программировании в стиле ООП основной акцент делается на объектах и их взаимодействии. Объекты представляют собой экземпляры классов, которые инкапсулируют состояние и поведение. ООП подразумевает использование наследования, полиморфизма и инкапсуляции для организации кода и упрощения его понимания. Основной принцип ООП - это разделение кода на небольшие, независимые объекты, которые могут взаимодействовать между собой. 
 
Процедурное программирование, с другой стороны, ориентировано на последовательное выполнение инструкций. Оно основано на использовании процедур (или функций), которые выполняют определенные действия. В процедурном программировании данные могут быть общими для различных процедур, и изменение данных может быть произведено в любой части программы. 
 
В итоге, основное отличие функционального программирования от ООП и процедурного стиля заключается в подходе к организации кода и управлению состоянием. Функциональное программирование ставит акцент на функции и их использование для решения задач, в то время как ООП и процедурное программирование ориентированы на объекты или процедуры соответственно.


1. Императивный подход к программированию?
Похож на приказы, то есть представляют собой последовательность команд, которые должен выполнить процессор.
Стили императивного подхода программирования:
Процедурный стиль = императивный + вызов других последовательностей команд (процедур)
Процеду́рное программи́рование — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.
Объектно-ориентированный стиль = группировка кода в классы
2. Декларативный подход к программированию?
Стиль, в котором задается спецификация решения задачи, то есть описывается ожидаемый результат, а не способ его получения.
Стили императивного подхода программирования:
Функциональный стиль = императивный + процедуры принимают параметры и возвращают значения
Логическое программирование - программы задаются в форме логических утверждений и правил вывода

Языки программирования и их подходы?
Императивные: C, C++, Java.
Декларативные: SQL, HTML.
Смешанные (и вашим и нашим): JavaScript, C#, Python.

Отличия от ооп и процедурного стиля:
- Программист вместо перечисления последовательности действий, нужных для получения результата, просто описывает, что он хочет получить.
- Программист сфокусирован на высокоуровневом “что требуется”, а не на низкоуровневом “как делать”.
- ФП не имеет механизма создания абстракций, потому-что основано на математических правилах.(Абстракция в JAVA «показывает» только необходимые атрибуты и «скрывает» ненужные детали объекта от пользователя.)
- У ФП есть проблемы с инкапсуляцией,
- ФП не пытается моделировать реальный мир. В ФП функциям позволено существовать отдельно от объектов

***Что такое инстанцирование?  Какие есть способы инстанцировать функциональные интерфейсы?***
Инстанцировать класс — это создать экземпляр класса (копию класса), (не объекта, а именно класса).
Инстанцировать можно только обычные классы. Интерфейсы нельзя


## 2. Что такое функциональный интерфейс?

Функциональный интерфейс в Java – это интерфейс, который содержит только 1 абстрактный метод.
Функциональный интерфейс может содержать любое количество методов с уровнем доступа `default` или `static`. Основное назначение – использование в лямбда выражениях и ссылках на метод.
 
Что такое абстрактные методы?
Абстрактный метод в Java - это метод, который объявлен в интерфейсе или абстрактном классе, но не имеет реализации в самом интерфейсе или абстрактном классе. Он предоставляет только сигнатуру метода, определяющую его имя, возвращаемый тип и параметры, но не содержит конкретной реализации. Классы, реализующие интерфейс или наследующие абстрактный класс, должны предоставить конкретную реализацию для всех абстрактных методов.

## 3. Зачем нужна аннотация @FunctionalInterface? Обязательна ли она?

Аннотация  не обязательна, но при её наличии код не скомпилируется, если будет больше или меньше, чем 1 абстрактный метод.
Рекомендуется добавлять @FunctionalInterface. Это позволит использовать интерфейс в лямбда выражениях, не остерегаясь того, что кто-то добавит в интерфейс новый абстрактный метод и он перестанет быть функциональным.

Aннотация @FunctionalInterface: ***что будет если написать два метода под ней?***
предупреждение компилятора об ошибке
“В интерфейсе Func обнаружено несколько абстрактных методов.”

## 4. Что такое default методы в интерфейсе и для чего они были введены?

Default-методы в интерфейсе - это методы, которые имеют реализацию по умолчанию в самом интерфейсе. Они были введены в Java 8 для обеспечения обратной совместимости при добавлении новых методов в существующие интерфейсы. 
Default-методы позволяют добавлять новые методы в интерфейсы, не нарушая существующий код, который реализует эти интерфейсы. Реализация default-метода предоставляется в самом интерфейсе, и классы, реализующие этот интерфейс, могут использовать эту реализацию по умолчанию или переопределить ее при необходимости. 
Default-методы могут быть переопределены в классе, реализующем интерфейс, чтобы предоставить свою собственную реализацию. При переопределении default-метода в классе будет использоваться новая реализация, а не реализация по умолчанию из интерфейса. 
Вызвать default-метод интерфейса в реализуемом его классе можно используя ключевое слово super вместе с именем интерфейса.
return Interface.super.method(element);

## 5. Может ли функциональный интерфейс содержать что-то кроме абстрактного метода?

Интерфейсы могут содержать поля, так же, как и обычные классы, но с несколькими отличиями:
- Поля должны быть проинициализированы.
- Поля считаются публичными статическими финальными.
- Модификаторы public, static и final не нужно указывать явно (они «проставляются» по умолчанию).
И могут содержать default методы

Может всё-таки можно в ФИ создать больше 1 абстрактного метода? (Да, но есть но)
Функциональные интерфейсы могут содержать дополнительно абстрактные методы, определенные в классе Object (вспоминаем третий модуль hashCode();
toString(); и т.д.). Если функциональный интерфейс переопределяет методы класса Object, то он будет наследовать реализацию по умолчанию для этих методов. 

## 6. Все способы реализации функционального интерфейса?

- Существует 4 способа реализации функционального интерфейса
- Через обычную имплементацию
- Через анонимный класс
- Через лямбду
- Через ссылку на метод (Method References)

Основные семейства функциональных интерфейсов (они обобщённые <>)? (6 семейств)

- Predicate<T>
Функциональный интерфейс Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T:
```
public interface Predicdte<T> {
    boolean test(T t);
}
```

- BinaryOperator<T>
BinaryOperator<T> принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T:
```
public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}
```

- UnaryOperator<T>
UnaryOperator<T> принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T:

```
public interface UnaryOperator<T> {
    T apply(T t);
}
```

- Function<T,R>
Функциональный интерфейс Function<T,R> представляет функцию перехода от объекта типа T к объекту типа R:

```
public interface Function<T,R> {
    R apply(T t);
}
```

- Consumer<T>
Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая:

```
public interface Consumer<T> {
    void accept(T t);
}
```

- Supplier<T>
Supplier<T> не принимает никаких аргументов, но должен возвращать объект типа T:

```
public interface Supplier<T> {
    T get();
}
```

Какие дополнительные, не относящиеся к этим семействам ФИ вы знаете? (Встроенные ФИ)
**Runnable, Comparator, Cloneable, Optional**

## 7. Что такое метод референс?
Ссылка на метод — это сокращенный синтаксис лямбда-выражения, который выполняет только ОДИН метод.
Ссылки на методы (Method References) – это компактные лямбда выражения для методов, у которых уже есть имя. 

Например:
`Cunsumer<String> consumer = str -> System.out.println(str);`
можно переписать с помощью method references:
`Cunsumer<String> consumer = System.out::println;`

В ссылке на метод вы помещаете объект (или класс), содержащий метод, перед ::оператором и имя.

Какие типы есть у ссылок на методы? (всего 4 типа сокращений)

В Java различают 4 вида ссылок на методы:
1. Ссылка на статический метод: Этот тип ссылки используется для вызова статического метода. 
Синтаксис:  ClassName::staticMethodName 

2. Ссылка на метод экземпляра объекта/класса: 
Синтаксис:  ClassName::instanceMethodName 
ClassName::new

3. Ссылка на конструктор: Этот тип ссылки используется для создания нового объекта с помощью конструктора.
Синтаксис:  ClassName::new . 

4. Ссылки на обобщенные (шаблонные) методы.
Ссылка на обобщенный метод имеет следующий синтаксис:  ClassName::<Type>methodName . Здесь  <Type>  указывает на параметризованный тип метода. 

## 8. Что такое «анонимные классы»? 
Анонимный класс в Java - это класс, который не имеет явного имени и создается в месте использования. Он позволяет определить и реализовать класс на месте, где он требуется, без необходимости создания отдельного класса для этой цели. 
Анонимные классы - это классы, что не имеют имени и их создание происходит в момент инициализации объекта. 


Чего НЕТ у анонимного класса?
Конструкторов

## 9. Как создать экземпляр анонимного класса?
Анонимный внутренний класс может быть создан из класса или интерфейса. Синтаксис: { что-то };
```
InterfaceName objectName = new InterfaceName() {
    // реализация методов интерфейса
};
AbstractClassName objectName = new AbstractClassName() {
    // реализация абстрактных методов
};
```
Данный синтаксис не позволяет указать extends, implements или имя класса. Вследствие этого анонимный класс может реализовать только один интерфейс.

Анонимные классы применяются в различных ситуациях, включая: 
 
1. Реализация интерфейсов: Анонимные классы могут использоваться для реализации интерфейсов в месте использования, когда требуется определенная функциональность, но нет необходимости в явном определении отдельного класса. 
3. Расширение абстрактных классов: Анонимные классы могут использоваться для создания подклассов абстрактных классов с небольшими изменениями, когда нет необходимости в полном определении отдельного класса. 
3. Создание объектов для передачи аргументов: Анонимные классы могут быть созданы для создания объектов, которые передаются в качестве аргументов методам или конструкторам. 

Рассмотрим небольшой пример. Предположим что у нас есть интерфейс, который необходимо реализовать. Для реализации можно создать отдельный класс, в нём реализовать интерфейс, далее создать объект на основе класса и через объект ссылаться на методы классы. Куда проще создать объект и для него сразу выполнить создание анонимного класса.

***Как создать экземпляр анонимного класса? ***

```
void extPrint() {
    External ext = new External() {
        String str = "Anonymous";
        void extPrint() {
            println("AnonymPrint"):
            super.extPrint();
            println("str = " + str);
            println("super.str = " + super.str);
        };
        ext.extPrint();
    }
}
```
Синтаксис определения анонимного класса включает также и создание экземпляра этого класса используя для этого ключевое слово new, за которым следует имя суперкласса или интерфейса и затем определение самого анонимного класса в фигурных скобках, за которыми следует точка с запятой.
создание анонимного класса и создание экземпляра анонимного класса тесно связаны между собой, поскольку создание экземпляра происходит на основе определения анонимного класса.
- Если имя, следующее за ключевым словом new, это имя класса, то анонимный класс является подклассом этого класса. 
- Если имя, следующее за ключевым словом new, представляет собой интерфейс, то анонимный класс реализует этот интерфейс и расширяет класс Object.
- Любые аргументы, которые вы укажете в круглых скобках, стоящих за именем родительского класса в определении анонимного класса, неявно передаются конструктору родительского класса.
- Для анонимных классов, компилятор передаёт в конструктор скрытую ссылку .this на окружающий класс. Поэтому к объекту окружающего класса можно обращаться  – через имя_внешнего_класса.this.
- Анонимные классы, имеют доступ к локальным переменным своего блока кода которые объявлены как final или они должны быть effectively final.
- Анонимные классы имеют доступ ко всем членам своего внешнего класса.
- Если в анонимном классе объявлена переменная с таким же именем, как и в окружающем классе, то она затеняет переменную окружающего класса.
- Анонимный класс не может содержать статические переменные, методы или классы, кроме констант static final. Интерфейс не может быть объявлен анонимно, потому что нет способа реализовать интерфейс без имени.

## 10. Что такое лямбда-выражение? Как его записать?
Лямбда-выражение в Java - это способ представления анонимной функции, которая может быть передана как аргумент или сохранена в переменной. Оно позволяет передавать код в более компактной и выразительной форме. 
Лямбда -выражения – это методы без объявления (без модификаторов доступа), возвращающие значение и имя. Они позволяют написать метод и сразу же использовать его. Особенно полезно в случае однократного вызова метода, т.к. сокращает время на объявление и написание метода без необходимости создавать отдельный класс.
Лямбда-выражение состоит из следующих элементов: 
 
1. Список параметров: Это список параметров, которые принимает лямбда-выражение. Если лямбда-выражение не принимает параметров, то пустые скобки используются для обозначения отсутствия параметров. Например:  `() ,  (x) ,  (x, y)` . 
2. Стрелка: Символ  ->  используется для разделения списка параметров и тела лямбда-выражения.
3. Тело лямбда-выражения: Это код, который выполняется при вызове лямбда-выражения. Он может быть одним выражением или блоком кода, заключенным в фигурные скобки. Например:  
   `x -> x * x ,  (x, y) -> x + y ,  () -> System.out.println("Hello") ,  (x, y) -> { int sum = x + y; return sum; } `. 

- Лямбда-выражения могут использоваться только в том случае, если вам нужно переопределить не более одного метода.
- Лямбда-выражения – это «всего лишь» новый способ сделать то же самое, но в более чистом и менее многословном способе использования анонимных внутренних классов.

***Как связаны лямбды и функц интерфейсы?***

Функциональный интерфейс - это интерфейс, который содержит только один абстрактный метод. Он служит основой для использования лямбда-выражений в Java. Лямбда-выражение представляет анонимную функцию, которая может быть присвоена переменной, передана в качестве аргумента или возвращена из метода. 

1. Лямбда представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.

2. Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

3. Лямбда выражения не содержат информацию о том, какой функциональный интерфейс они реализуют.

4. Тип выражения выводится из контекста, в котором используется лямбда выражение. Этот тип называется целевой тип (`target type`).

5. Если лямбда выражение присваивается какому-то интерфейсу, лямбда выражение должно соответствовать синтаксису метода интерфейса.

6. Одно и то же лямбда выражение может использоваться с разными интерфейсами, если они имеют абстрактные методы, которые совместимы.

***Любой анонимный класс можно заменить на лямбду?***
Нет, только если анонимный класс создан, как реализация функционального интерфейса.

***Как лямбда связана с анонимным классом?***

Лямбда-выражение связано с анонимным классом в том смысле, что оно предоставляет более краткий и удобный синтаксис для определения функциональных интерфейсов. Оба подхода позволяют передавать поведение в виде аргумента метода или присваивать его переменной. 
 
Однако, есть несколько ключевых различий между лямбда-выражениями и анонимными классами: 
 
1. Синтаксис: Лямбда-выражения имеют более компактный синтаксис, чем анонимные классы. Они позволяют определить функциональный интерфейс с помощью стрелки  -> , без явного указания имени класса или метода. 
 
2. Контекст типа: Лямбда-выражения могут использовать контекст типа для вывода типов параметров, что делает код более читаемым и уменьшает необходимость явного указания типов. 
 
3. Захват переменных: Лямбда-выражения могут захватывать значения переменных из окружающей области видимости. В отличие от анонимных классов, лямбда-выражения могут использовать финальные или эффективно финальные переменные без явного объявления. 
 
4. Семантика  this : В лямбда-выражениях ключевое слово  this  ссылается на окружающий контекст, тогда как в анонимных классах оно ссылается на сам анонимный класс. 

***Final и effective final?***

Разница между final и «effectively final» заключается в том, что final является ключевым словом, которое применяется при объявлении переменной и означает, что ее значение не может быть изменено после инициализации, тогда как «effectively final» — это понятие, которое означает, что значение переменной не изменяется после инициализации, даже если она не объявлена как final.


## 11. Расскажите про Comparator и Comparable?
Comparator и Comparable - это два интерфейса в Java, которые используются для сравнения объектов. Они имеют различные подходы к сравнению и предоставляют разные возможности. 
 
1. Comparable: 
   - Comparable - это интерфейс, сравнивает текущий объект с объектом, переданным в качестве параметра.    
   - Класс, реализующий Comparable, определяет естественный порядок сортировки для своих объектов. 
   - Метод  compareTo()  определен в интерфейсе Comparable и должен быть реализован классом, чтобы указать, как сравнивать объекты. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.
   - Comparable используется в основном для сортировки объектов в натуральном порядке. 
 
2. Comparator: 
   - Comparator - это интерфейс, который используется для сравнения двух объектов. 
   - Класс, реализующий Comparator, предоставляет специфическую логику сравнения объектов. 
   - Метод  compare()  определен в интерфейсе Comparator и должен быть реализован классом, чтобы указать, как сравнивать объекты. 
   - Comparator позволяет создавать несколько различных способов сравнения объектов, не изменяя их самих. 
 
Comparable - имплементится самим классом, когда нужен натуральный порядок сортировки. Пример - класс String.

Comparator - имплементится другими классами. Дает возможность отделить реализацию сравнения от класса и сделать несколько реализаций сравнения по разным параметрам для одного класса.
 
Важно отметить, что Comparable используется для сравнения объектов по умолчанию, тогда как Comparator может быть использован для сравнения объектов в любом контексте, включая сортировку коллекций или другие операции сравнения.

## 12. Что такое стримы? Для чего они нужны? Когда их лучше использовать?
Стримы (Streams) в Java представляют собой последовательность элементов, которые могут быть обработаны параллельно или последовательно. Они предоставляют удобный и выразительный способ работы с коллекциями и другими источниками данных. 

Stream API это новый способ работать со структурами данных в функциональном стиле.
- Ключевым понятием в Stream API является поток данных. Применительно к Stream API поток представляет канал передачи данных из источника данных. Причём в качестве источника могут выступать как файлы, так и массивы и коллекции.
Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.

Таким образом, использование стримов в Java рекомендуется в случаях, когда требуется обработка больших объемов данных, фильтрация и трансформация данных, композиция операций и улучшение читаемости кода.

## 13. Какие есть виды стримов?
- Stream<T>: используется для потоков данных, представляющих любой ссылочный тип
- IntStream: используется для потоков с типом данных int
- DoubleStream: используется для потоков с типом данных double
- LongStream: используется для потоков с типом данных long

Для boolean, byte, short и char специальных стримов не придумали, но вместо них можно использовать IntStream, а затем приводить к нужному типу. Для float придётся воспользоваться DoubleStream.

***Методы BaseStream?***

- void close(): закрывает поток
- boolean isParallel(): возвращает true, если поток является параллельным
- Iterator<Т> iterator(): возвращает ссылку на итератор потока
- Spliterator<Т> spliterator(): возвращает ссылку на сплитератор потока
- parallel(): возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)
- sequential(): возвращает последовательный поток
- unordered(): возвращает неупорядоченный поток

## 14. Способы создания Стрима?
- Из коллекции: 
`Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();`

- Из набора значений:
`Stream<String> fromValues = Stream.of("x", "y", "z");`

- Из массива:
`Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});`

- Из файла (каждая строка в файле будет отдельным элементом в стриме):
`Stream<String> fromFile = Files.lines(Paths.get("input.txt"));`

- Из строки:
`IntStream fromString = "0123456789".chars();`

- С помощью Stream.builder():
`Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();`

- С помощью Stream.iterate() (бесконечный):
`Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);`

- С помощью Stream.generate() (бесконечный):
`Stream<String> fromGenerate = Stream.generate(() -> "0");`

***Из каких этапов состоит жизненный цикл стрима?***
1) Создание потока.
2) Применение к потоку ряда промежуточных операторов (их может быть несколько).
- Промежуточные (intermediate) – возвращают другой stream, то есть работают как builder;
3) Применение к потоку терминального оператора.
- Терминальная операция(terminal) - возвращает другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.
- Может быть только один в конце выражения.

Общее правило: у stream’a, может быть, сколько угодно промежуточных операций и в конце одна терминальная, при этом все промежуточные методы выполняются лениво и пока не будет вызван терминальный метод никаких действий на самом деле не происходит.

***В чем разница между Collection и Stream?***
- Потоки не хранят элементы. Элементы, используемые в потоках, могут храниться в коллекции, либо при необходимости могут быть напрямую сгенерированы.
- Операции с потоками не изменяют источника данных. Операции с потоками лишь возвращают новый поток с результатами этих операций.
- Для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток.

Разница между коллекцией(Collection) данных и потоком(Stream) в том, что коллекции позволяют работать с элементами по-отдельности, тогда как поток(Stream) не позволяет. Например, с использованием коллекций, вы можете добавлять элементы, удалять, и вставлять в середину. Поток(Stream) не позволяет манипулировать отдельными элементами из набора данных, но вместо этого позволяет выполнять функции над данными как одним целом.


## 15. Что такое терминальная операция?
Промежуточные операции следует воспринимать как «отложенные», т.е. они не меняют сами данные, а только задают правила их изменения. А терминальные как раз инициируют всю цепочку преобразований, закрывают поток и возвращают модифицированные данные. Закрытый поток повторно использовать нельзя.

5 примеров промежуточных операций (intermediate методы) и знать 5 примеров терминальных операций
Промежуточные операции (Intermediate operations) в стримах Java выполняются над элементами стрима и возвращают новый стрим. Они не выполняются немедленно, а ожидают выполнения терминальной операции. Вот пять примеров промежуточных операций: 
 
1.  filter : Фильтрация элементов стрима на основе заданного условия. Например:
stream.filter(element -> element > 5)

2.  map : Преобразование каждого элемента стрима в другой объект или значение. Например:
stream.map(element -> element * 2)

3.  distinct : Удаление дубликатов из стрима. Например:
stream.distinct()

4.  sorted : Сортировка элементов стрима в заданном порядке. Например:
stream.sorted()

5.  limit : Ограничение количества элементов в стриме. Например:
stream.limit(10)

6. peek

Терминальные операции (Terminal operations) в стримах Java выполняются после промежуточных операций и возвращают результат или побочный эффект. Вот пять примеров терминальных операций: 
 
-  forEach : Выполнение заданного действия для каждого элемента стрима. Например:
stream.forEach(System.out::println)
-  collect : Сбор элементов стрима в коллекцию или другую структуру данных. Например:
stream.collect(Collectors.toList())
-  count : Подсчет количества элементов в стриме. Например:
stream.count()
-  allMatch: Проверка, удовлетворяют ли все элементы стрима заданному условию. Например:
stream.anyMatch(element -> element > 10)
-  reduce : Сокращение элементов стрима до одного значения с помощью заданной операции. Например:
stream.reduce((a, b) -> a + b)


## 16. Что возвращают промежуточные операции над стримом?
Промежуточные операции возвращают трансформированный поток. Например, выше в примере метод filter принимал поток чисел и возвращал уже преобразованный поток, в котором только числа больше 0. К возвращенному потоку также можно применить ряд промежуточных операций.

## 17. В чем разница map и flatMap?

Выражения map(lambda) и flatMap(lambda) оба применяют анонимную функцию lambda к каждому элементу стрима. Разница в том, что lambda для map возвращает ровно один элемент для каждого элемента стрима, а lambda для flatMap возвращает какой-то стрим для каждого элемента (и все такие стримы склеиваются в один).
Метод  flatMap  также применяет функцию к каждому элементу в потоке, но в отличие от  map , функция должна возвращать поток элементов. Затем  flatMap  объединяет все полученные потоки в один плоский поток. То есть, результатом операции  flatMap  будет плоский поток элементов, полученных из всех возвращаемых потоков функцией. 

Пример из документации Java: Если orders — стрим заказов, а каждый заказ включает в себя несколько купленных вещей (line items), то получить стрим из всех купленных вещей можно так:

 orders.flatMap(order -> order.getLineItems().stream())

В Java  map  и  flatMap  также являются операциями, используемыми для преобразования элементов в коллекции или потоке. Они имеют схожие концепции, но есть некоторые отличия. 

Какие бывают стримы? (3 группы)
1. Конечные и бесконечные стримы: Конечные стримы имеют определенное количество элементов и завершаются после обработки всех элементов в потоке. Бесконечные стримы не имеют конечного числа элементов и могут продолжаться бесконечно. 
 
2. Последовательные и параллельные стримы: Последовательные стримы обрабатывают элементы последовательно, один за другим. Параллельные стримы используют несколько потоков для параллельной обработки элементов, что может привести к ускорению выполнения операций. 
 
3. Объектные и примитивные стримы: Объектные стримы предназначены для работы с объектами любого типа. Примитивные стримы предоставляют специализированные операции для работы с примитивными типами данных, такими как  int ,  long  или  double . Примитивные стримы могут быть эффективнее объектных стримов в некоторых случаях. 

Чтобы получить параллельный стрим, нужно либо вызвать метод parallelStream() вместо stream(), либо превратить обычный стрим в параллельный, вызвав промежуточный оператор parallel.
Так же мы можем преобразовать параллельный поток в последовательный вызовом метода sequential().

В каком случае нужно закрывать стрим?
Для обычного Stream, экземпляр потока не нужно закрывать после использования.
`try (Stream lines = Files.lines(Paths.get(path))) {`
Для потока, источником которого является канал ввода-вывода, закройте его с помощью try-with-resources.


## 18. Что такое ленивая инициализация стрима?
Ленивая инициализация-это оптимизация производительности, при которой вы откладываете (потенциально дорогостоящее) создание объекта до тех пор, пока оно вам действительно не понадобится.

Терминальный оператор запрашивает у промежуточных данные для обработки, если данные не поступают, то выполнение стрима не начинается. Если данные поступили, то происходит их обработка промежуточными операторами с последующей передачей терминальному по цепочке.

Отложенная (ленивая) инициализация — приём в программировании, когда некоторая ресурсоёмкая операция (создание объекта, вычисление значения) выполняется непосредственно перед тем, как будет использован её результат. Таким образом, инициализация выполняется «по требованию», а не заблаговременно.
Плюсы:
- Инициализация выполняется только в тех случаях, когда она действительно необходима;
- Ускоряется начальная инициализация.
Минусы:
- Невозможно явным образом задать порядок инициализации объектов;
- Возникает задержка при первом обращении к объекту.

***Как получить стрим диапазона чисел?***
`IntStream.range(0, 10).forEach(System.out::println);`
При помощи метода range().

## 19. Можно ли вызвать 2 терминальные операции?

Нет.

## 20. Что будет, если терминальной операции не будет?
У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит. То есть без терминальной операции ничего не будет

***ЧТО возвращают промежуточные операции в стримах? А терминальные? (void и ...)***

Операции над стримами бывают или *промежуточными (intermediate)* или *конечными (terminal)*. Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.

У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит

***Для чего нужен метод collect() в стримах?***

Метод `collect()` является конечной операцией, которая используется для представление результата в виде коллекции или какой-либо другой структуры данных.

`collect()` принимает на вход `Collector<Тип_источника, Тип_аккумулятора, Тип_результата>`, содержит четыре основных компонента: 
 1.  Supplier : Функция, которая создает и возвращает контейнер для накопления элементов. 
 
2.  Accumulator : Функция, которая добавляет элементы в контейнер. 
 
3.  Combiner : Функция, которая объединяет промежуточные результаты сборки, когда параллельно обрабатываются несколько частей стрима. 
 
4.  Finisher : Функция, которая выполняет окончательные операции над результатом сборки и возвращает конечный результат. 

В Java 8 в классе `Collectors` реализовано несколько распространённых коллекторов:

- `toList()`, `toCollection()`, `toSet()` - представляют стрим в виде списка, коллекции или множества;
- `toConcurrentMap()`, `toMap()` - позволяют преобразовать стрим в `Mindmap`;
- `averagingInt()`, `averagingDouble()`, `averagingLong()` - возвращают среднее значение;
- `summingInt()`, `summingDouble()`, `summingLong()` - возвращает сумму;
- `summarizingInt()`, `summarizingDouble()`, `summarizingLong()` - возвращают `SummaryStatistics` с разными агрегатными значениями;
- `partitioningBy()` - разделяет коллекцию на две части по соответствию условию и возвращает их как `Mindmap<Boolean, List>`;
- `groupingBy()` - разделяет коллекцию на несколько частей и возвращает `Mindmap<N, List<T>>`;
- `mapping()` - дополнительные преобразования значений для сложных `Collector`.

## 21. Может ли стрим использоваться повторно?

Нет, это одноразовая сущность

## 22. Для чего нужны параллельные стримы?

Параллельные стримы в Java предназначены для параллельной обработки данных. Они позволяют распределить работу по нескольким потокам, что может значительно улучшить производительность при обработке больших объемов данных. 
 
Использование параллельных стримов особенно полезно, когда у вас есть операции, которые можно выполнять независимо друг от друга. Например, если у вас есть список элементов, и вы хотите применить к каждому элементу какую-то функцию, параллельные стримы позволяют распределить выполнение этой функции по нескольким потокам, что ускоряет обработку. 
 
Для создания параллельного стрима в Java, вы можете вызвать метод  parallel()  на существующем стриме. Например:

```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

//Создание параллельного стрима
Stream<Integer> parallelStream = numbers.parallelSream();

//Пример применения операции к каждому элементу
parallelStream.map(x -> x * 2)
                .forEach(System.out::println);                
```

В этом примере, вызов  parallelStream()  на списке чисел создает параллельный стрим. Затем мы применяем функцию умножения к каждому элементу и выводим результаты на консоль. 
 
Однако, стоит отметить, что не всегда параллельные стримы будут давать значительное увеличение производительности. Иногда они могут быть медленнее, чем последовательные стримы, из-за накладных расходов на управление потоками и синхронизацию. Поэтому перед использованием параллельных стримов рекомендуется провести тестирование производительности и оценить, действительно ли они улучшают производительность вашего конкретного случая.


## 23. В чём разница между forEach и peek?
В Java разница между  forEach  и  peek  заключается в том, как они взаимодействуют с элементами потока данных. 
 
 forEach  - это терминальная операция, которая выполняет заданное действие для каждого элемента потока. Она не возвращает новый поток и не изменяет исходный поток.  forEach  просто выполняет указанное действие для каждого элемента и больше ничего не делает. 
 
 peek , с другой стороны, является промежуточной операцией и возвращает новый поток, который содержит те же элементы, что и исходный поток. Однако  peek  также выполняет заданное действие для каждого элемента, как и  forEach . Это позволяет наблюдать (проверить) элементы потока, не изменяя его содержимого. 

***ля чего нужны методы forEach() и forEachOrdered()***
- `forEach()` применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется;
- `forEachOrdered()` применяет функцию к каждому объекту стрима с сохранением порядка элементов.
